<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tree: fcarouge::tree&lt; Type, AllocatorType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tree
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">Tree data structure for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classfcarouge_1_1tree.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="classfcarouge_1_1tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fcarouge::tree&lt; Type, AllocatorType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A tree data structure for C++.  
 <a href="classfcarouge_1_1tree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tree_8hpp_source.html">tree.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for fcarouge::tree&lt; Type, AllocatorType &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classfcarouge_1_1tree__coll__graph.png" border="0" usemap="#afcarouge_1_1tree_3_01_type_00_01_allocator_type_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="afcarouge_1_1tree_3_01_type_00_01_allocator_type_01_4_coll__map" id="afcarouge_1_1tree_3_01_type_00_01_allocator_type_01_4_coll__map">
<area shape="rect" title="A tree data structure for C++." alt="" coords="112,344,307,2020"/>
<area shape="rect" title=" " alt="" coords="5,167,157,259"/>
<area shape="rect" title=" " alt="" coords="181,175,237,252"/>
<area shape="rect" href="structfcarouge_1_1tree_1_1internal__node__type.html" title="Branch node data structure type." alt="" coords="261,145,427,281"/>
<area shape="rect" title=" " alt="" coords="302,5,386,83"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfcarouge_1_1tree_1_1insert__return__type.html">insert_return_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result type of inserting a <code><a class="el" href="classfcarouge_1_1tree_1_1node__type.html" title="The node handle type of the container.">node_type</a></code> in the container.  <a href="structfcarouge_1_1tree_1_1insert__return__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfcarouge_1_1tree_1_1internal__const__iterator__type.html">internal_const_iterator_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to identify and traverse the constant elements of the container.  <a href="structfcarouge_1_1tree_1_1internal__const__iterator__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfcarouge_1_1tree_1_1internal__iterator__type.html">internal_iterator_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to identify and traverse the elements of the container.  <a href="structfcarouge_1_1tree_1_1internal__iterator__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Branch node data structure type.  <a href="structfcarouge_1_1tree_1_1internal__node__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree_1_1node__type.html">node_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The node handle type of the container.  <a href="classfcarouge_1_1tree_1_1node__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Member Types</div></td></tr>
<tr class="memitem:ad1368e9366d469e64eaf5248d7302995"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#ad1368e9366d469e64eaf5248d7302995">value_type</a> = Type</td></tr>
<tr class="memdesc:ad1368e9366d469e64eaf5248d7302995"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the contained data elements.  <a href="classfcarouge_1_1tree.html#ad1368e9366d469e64eaf5248d7302995">More...</a><br /></td></tr>
<tr class="separator:ad1368e9366d469e64eaf5248d7302995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f330c299956045bde353a072492ad0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#ae5f330c299956045bde353a072492ad0">allocator_type</a> = AllocatorType</td></tr>
<tr class="memdesc:ae5f330c299956045bde353a072492ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the allocator for all memory allocations of this container.  <a href="classfcarouge_1_1tree.html#ae5f330c299956045bde353a072492ad0">More...</a><br /></td></tr>
<tr class="separator:ae5f330c299956045bde353a072492ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6cd0c0c176c23f9843dbf5f4ea5eb30"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#ae6cd0c0c176c23f9843dbf5f4ea5eb30">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:ae6cd0c0c176c23f9843dbf5f4ea5eb30"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unsigned integer type to represent element counts.  <a href="classfcarouge_1_1tree.html#ae6cd0c0c176c23f9843dbf5f4ea5eb30">More...</a><br /></td></tr>
<tr class="separator:ae6cd0c0c176c23f9843dbf5f4ea5eb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca46de39685c48952bd45a578e3bd8d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a8ca46de39685c48952bd45a578e3bd8d">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:a8ca46de39685c48952bd45a578e3bd8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type to represent element distances.  <a href="classfcarouge_1_1tree.html#a8ca46de39685c48952bd45a578e3bd8d">More...</a><br /></td></tr>
<tr class="separator:a8ca46de39685c48952bd45a578e3bd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d21cbaae60bbcaa55f0ea7432ee293"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a85d21cbaae60bbcaa55f0ea7432ee293">reference</a> = <a class="el" href="classfcarouge_1_1tree.html#ad1368e9366d469e64eaf5248d7302995">value_type</a> &amp;</td></tr>
<tr class="memdesc:a85d21cbaae60bbcaa55f0ea7432ee293"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reference type of the contained data elements.  <a href="classfcarouge_1_1tree.html#a85d21cbaae60bbcaa55f0ea7432ee293">More...</a><br /></td></tr>
<tr class="separator:a85d21cbaae60bbcaa55f0ea7432ee293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9bb13758156a46bc7230dd86f58716"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#abc9bb13758156a46bc7230dd86f58716">const_reference</a> = const <a class="el" href="classfcarouge_1_1tree.html#ad1368e9366d469e64eaf5248d7302995">value_type</a> &amp;</td></tr>
<tr class="memdesc:abc9bb13758156a46bc7230dd86f58716"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constant reference type of the contained data elements.  <a href="classfcarouge_1_1tree.html#abc9bb13758156a46bc7230dd86f58716">More...</a><br /></td></tr>
<tr class="separator:abc9bb13758156a46bc7230dd86f58716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa318e3abfbfa6655010512a9727b7ac2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#aa318e3abfbfa6655010512a9727b7ac2">pointer</a> = typename std::allocator_traits&lt; AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html#aa318e3abfbfa6655010512a9727b7ac2">pointer</a></td></tr>
<tr class="memdesc:aa318e3abfbfa6655010512a9727b7ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pointer type of the contained data elements.  <a href="classfcarouge_1_1tree.html#aa318e3abfbfa6655010512a9727b7ac2">More...</a><br /></td></tr>
<tr class="separator:aa318e3abfbfa6655010512a9727b7ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03614438bc62228f67b08f2eeadfa803"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a03614438bc62228f67b08f2eeadfa803">const_pointer</a> = typename std::allocator_traits&lt; AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html#a03614438bc62228f67b08f2eeadfa803">const_pointer</a></td></tr>
<tr class="memdesc:a03614438bc62228f67b08f2eeadfa803"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const pointer type of the contained data elements.  <a href="classfcarouge_1_1tree.html#a03614438bc62228f67b08f2eeadfa803">More...</a><br /></td></tr>
<tr class="separator:a03614438bc62228f67b08f2eeadfa803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa347e61a1909cfadea9952d73cf23b2f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a> = <a class="el" href="structfcarouge_1_1tree_1_1internal__iterator__type.html">internal_iterator_type</a></td></tr>
<tr class="memdesc:aa347e61a1909cfadea9952d73cf23b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to identify and traverse the elements of the container.  <a href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">More...</a><br /></td></tr>
<tr class="separator:aa347e61a1909cfadea9952d73cf23b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244d6ea314f6207eb38966382beb3d4d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a> = <a class="el" href="structfcarouge_1_1tree_1_1internal__const__iterator__type.html">internal_const_iterator_type</a></td></tr>
<tr class="memdesc:a244d6ea314f6207eb38966382beb3d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant type to identify and traverse the elements of the container.  <a href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">More...</a><br /></td></tr>
<tr class="separator:a244d6ea314f6207eb38966382beb3d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Member Functions</div></td></tr>
<tr class="memitem:ac28ef9d25d4cf3d18067f119eab052d6"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#ac28ef9d25d4cf3d18067f119eab052d6">tree</a> () noexcept(noexcept(AllocatorType{}))=default</td></tr>
<tr class="memdesc:ac28ef9d25d4cf3d18067f119eab052d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with a default-constructed allocator.  <a href="classfcarouge_1_1tree.html#ac28ef9d25d4cf3d18067f119eab052d6">More...</a><br /></td></tr>
<tr class="separator:ac28ef9d25d4cf3d18067f119eab052d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f3550ee53f8886354b6ffba790a25b"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a73f3550ee53f8886354b6ffba790a25b">tree</a> (const AllocatorType &amp;allocator)</td></tr>
<tr class="memdesc:a73f3550ee53f8886354b6ffba790a25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with the given allocator.  <a href="classfcarouge_1_1tree.html#a73f3550ee53f8886354b6ffba790a25b">More...</a><br /></td></tr>
<tr class="separator:a73f3550ee53f8886354b6ffba790a25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292f8628856bc6ac097969c8e5921cab"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a292f8628856bc6ac097969c8e5921cab">tree</a> (const <a class="el" href="classfcarouge_1_1tree.html">tree</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a292f8628856bc6ac097969c8e5921cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classfcarouge_1_1tree.html#a292f8628856bc6ac097969c8e5921cab">More...</a><br /></td></tr>
<tr class="separator:a292f8628856bc6ac097969c8e5921cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67dc01f098aac069e73a90b84e53e3ea"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a67dc01f098aac069e73a90b84e53e3ea">tree</a> (const <a class="el" href="classfcarouge_1_1tree.html">tree</a> &amp;other, const AllocatorType &amp;allocator)</td></tr>
<tr class="memdesc:a67dc01f098aac069e73a90b84e53e3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator-extended copy constructor.  <a href="classfcarouge_1_1tree.html#a67dc01f098aac069e73a90b84e53e3ea">More...</a><br /></td></tr>
<tr class="separator:a67dc01f098aac069e73a90b84e53e3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d87b206f6c94e206ded34cf15770b0"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#af5d87b206f6c94e206ded34cf15770b0">tree</a> (<a class="el" href="classfcarouge_1_1tree.html">tree</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:af5d87b206f6c94e206ded34cf15770b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classfcarouge_1_1tree.html#af5d87b206f6c94e206ded34cf15770b0">More...</a><br /></td></tr>
<tr class="separator:af5d87b206f6c94e206ded34cf15770b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf8bbfc541eb153be0051b3bab67d12"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#afbf8bbfc541eb153be0051b3bab67d12">tree</a> (<a class="el" href="classfcarouge_1_1tree.html">tree</a> &amp;&amp;other, const AllocatorType &amp;allocator) noexcept</td></tr>
<tr class="memdesc:afbf8bbfc541eb153be0051b3bab67d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator-extended move constructor.  <a href="classfcarouge_1_1tree.html#afbf8bbfc541eb153be0051b3bab67d12">More...</a><br /></td></tr>
<tr class="separator:afbf8bbfc541eb153be0051b3bab67d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b968f91ee2885982251f35dee38c7e4"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a3b968f91ee2885982251f35dee38c7e4">tree</a> (<a class="el" href="classfcarouge_1_1tree.html#abc9bb13758156a46bc7230dd86f58716">const_reference</a> value)</td></tr>
<tr class="memdesc:a3b968f91ee2885982251f35dee38c7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with by copying the value for its root.  <a href="classfcarouge_1_1tree.html#a3b968f91ee2885982251f35dee38c7e4">More...</a><br /></td></tr>
<tr class="separator:a3b968f91ee2885982251f35dee38c7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec971aec16ee59380a9e1ce1def7aa4"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a2ec971aec16ee59380a9e1ce1def7aa4">tree</a> (<a class="el" href="classfcarouge_1_1tree.html#abc9bb13758156a46bc7230dd86f58716">const_reference</a> value, const AllocatorType &amp;allocator)</td></tr>
<tr class="memdesc:a2ec971aec16ee59380a9e1ce1def7aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with by copying the value for its root.  <a href="classfcarouge_1_1tree.html#a2ec971aec16ee59380a9e1ce1def7aa4">More...</a><br /></td></tr>
<tr class="separator:a2ec971aec16ee59380a9e1ce1def7aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710787518476c198a669d77a33c3ddf8"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a710787518476c198a669d77a33c3ddf8">tree</a> (<a class="el" href="classfcarouge_1_1tree.html#ad1368e9366d469e64eaf5248d7302995">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:a710787518476c198a669d77a33c3ddf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container by moving the value for its root.  <a href="classfcarouge_1_1tree.html#a710787518476c198a669d77a33c3ddf8">More...</a><br /></td></tr>
<tr class="separator:a710787518476c198a669d77a33c3ddf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b14c726ea8b5aff6371f3f3f9016cb3"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a4b14c726ea8b5aff6371f3f3f9016cb3">tree</a> (<a class="el" href="classfcarouge_1_1tree.html#ad1368e9366d469e64eaf5248d7302995">value_type</a> &amp;&amp;value, const AllocatorType &amp;allocator)</td></tr>
<tr class="memdesc:a4b14c726ea8b5aff6371f3f3f9016cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container by moving the value for its root.  <a href="classfcarouge_1_1tree.html#a4b14c726ea8b5aff6371f3f3f9016cb3">More...</a><br /></td></tr>
<tr class="separator:a4b14c726ea8b5aff6371f3f3f9016cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e97ce6cb6385676b59aae76e18fef31"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a3e97ce6cb6385676b59aae76e18fef31">~tree</a> () noexcept</td></tr>
<tr class="memdesc:a3e97ce6cb6385676b59aae76e18fef31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs the container.  <a href="classfcarouge_1_1tree.html#a3e97ce6cb6385676b59aae76e18fef31">More...</a><br /></td></tr>
<tr class="separator:a3e97ce6cb6385676b59aae76e18fef31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2887816b7f092fc401938e669d70b4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html">tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a6b2887816b7f092fc401938e669d70b4">operator=</a> (const <a class="el" href="classfcarouge_1_1tree.html">tree</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a6b2887816b7f092fc401938e669d70b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="classfcarouge_1_1tree.html#a6b2887816b7f092fc401938e669d70b4">More...</a><br /></td></tr>
<tr class="separator:a6b2887816b7f092fc401938e669d70b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc33736760cfa53031240e46cb57e4a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html">tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#aacc33736760cfa53031240e46cb57e4a">operator=</a> (<a class="el" href="classfcarouge_1_1tree.html">tree</a> &amp;&amp;other) noexcept(noexcept(this-&gt;<a class="el" href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">node_allocator</a>=std::move(other.node_allocator)))</td></tr>
<tr class="memdesc:aacc33736760cfa53031240e46cb57e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classfcarouge_1_1tree.html#aacc33736760cfa53031240e46cb57e4a">More...</a><br /></td></tr>
<tr class="separator:aacc33736760cfa53031240e46cb57e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdcdfb8c62a8753e1c3ad3c21f604eb"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html">tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a0cdcdfb8c62a8753e1c3ad3c21f604eb">operator=</a> (<a class="el" href="classfcarouge_1_1tree.html#abc9bb13758156a46bc7230dd86f58716">const_reference</a> value) noexcept</td></tr>
<tr class="memdesc:a0cdcdfb8c62a8753e1c3ad3c21f604eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value copy assignment operator.  <a href="classfcarouge_1_1tree.html#a0cdcdfb8c62a8753e1c3ad3c21f604eb">More...</a><br /></td></tr>
<tr class="separator:a0cdcdfb8c62a8753e1c3ad3c21f604eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bd9c0bba29aff00363a210996ba14c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html">tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a98bd9c0bba29aff00363a210996ba14c">operator=</a> (<a class="el" href="classfcarouge_1_1tree.html#ad1368e9366d469e64eaf5248d7302995">value_type</a> &amp;&amp;value) noexcept</td></tr>
<tr class="memdesc:a98bd9c0bba29aff00363a210996ba14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value move assignment operator.  <a href="classfcarouge_1_1tree.html#a98bd9c0bba29aff00363a210996ba14c">More...</a><br /></td></tr>
<tr class="separator:a98bd9c0bba29aff00363a210996ba14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2adeaaf61d4ec87bf58d22689fa7aa"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html">tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#afa2adeaaf61d4ec87bf58d22689fa7aa">assign</a> (const <a class="el" href="classfcarouge_1_1tree.html">tree</a> &amp;other) noexcept</td></tr>
<tr class="separator:afa2adeaaf61d4ec87bf58d22689fa7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f15335a7dcc09697cb4a64507547b9a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html">tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a2f15335a7dcc09697cb4a64507547b9a">assign</a> (<a class="el" href="classfcarouge_1_1tree.html">tree</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a2f15335a7dcc09697cb4a64507547b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2f4cb1caf5a71e1a298ab6e5460955"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html">tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a5f2f4cb1caf5a71e1a298ab6e5460955">assign</a> (<a class="el" href="classfcarouge_1_1tree.html#abc9bb13758156a46bc7230dd86f58716">const_reference</a> value) noexcept</td></tr>
<tr class="separator:a5f2f4cb1caf5a71e1a298ab6e5460955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd1f973e74cfbed19867a43e700b0ba"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html">tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#abdd1f973e74cfbed19867a43e700b0ba">assign</a> (<a class="el" href="classfcarouge_1_1tree.html#ad1368e9366d469e64eaf5248d7302995">value_type</a> &amp;&amp;value) noexcept</td></tr>
<tr class="separator:abdd1f973e74cfbed19867a43e700b0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c65db35e938093e6b0a210630f1d84d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html#ae5f330c299956045bde353a072492ad0">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a9c65db35e938093e6b0a210630f1d84d">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:a9c65db35e938093e6b0a210630f1d84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container.  <a href="classfcarouge_1_1tree.html#a9c65db35e938093e6b0a210630f1d84d">More...</a><br /></td></tr>
<tr class="separator:a9c65db35e938093e6b0a210630f1d84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Element Access Member Functions</div></td></tr>
<tr class="memitem:a1452f7fc3685dd1e35314f1488f04693"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html#a85d21cbaae60bbcaa55f0ea7432ee293">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a1452f7fc3685dd1e35314f1488f04693">front</a> ()</td></tr>
<tr class="memdesc:a1452f7fc3685dd1e35314f1488f04693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <a href="classfcarouge_1_1tree.html#a1452f7fc3685dd1e35314f1488f04693">More...</a><br /></td></tr>
<tr class="separator:a1452f7fc3685dd1e35314f1488f04693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27dfcb2f1ab3f3f1f2d12c78fa416241"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html#abc9bb13758156a46bc7230dd86f58716">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a27dfcb2f1ab3f3f1f2d12c78fa416241">front</a> () const</td></tr>
<tr class="memdesc:a27dfcb2f1ab3f3f1f2d12c78fa416241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the first element in the container.  <a href="classfcarouge_1_1tree.html#a27dfcb2f1ab3f3f1f2d12c78fa416241">More...</a><br /></td></tr>
<tr class="separator:a27dfcb2f1ab3f3f1f2d12c78fa416241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Iterator Member Functions</div></td></tr>
<tr class="memitem:a217fb2d8d248bedec9126214e8c891a2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a217fb2d8d248bedec9126214e8c891a2">begin</a> () noexcept</td></tr>
<tr class="memdesc:a217fb2d8d248bedec9126214e8c891a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="classfcarouge_1_1tree.html#a217fb2d8d248bedec9126214e8c891a2">More...</a><br /></td></tr>
<tr class="separator:a217fb2d8d248bedec9126214e8c891a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4986566354e05a0d3f8b263799e42e45"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a4986566354e05a0d3f8b263799e42e45">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a4986566354e05a0d3f8b263799e42e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the first element of the container.  <a href="classfcarouge_1_1tree.html#a4986566354e05a0d3f8b263799e42e45">More...</a><br /></td></tr>
<tr class="separator:a4986566354e05a0d3f8b263799e42e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d914f8d4ce69f0ecd580e7ddb5d16d1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a4d914f8d4ce69f0ecd580e7ddb5d16d1">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a4d914f8d4ce69f0ecd580e7ddb5d16d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the first element of the container.  <a href="classfcarouge_1_1tree.html#a4d914f8d4ce69f0ecd580e7ddb5d16d1">More...</a><br /></td></tr>
<tr class="separator:a4d914f8d4ce69f0ecd580e7ddb5d16d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca5d640f5205c58695f271bea0fd8ac"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#afca5d640f5205c58695f271bea0fd8ac">end</a> () noexcept</td></tr>
<tr class="memdesc:afca5d640f5205c58695f271bea0fd8ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="classfcarouge_1_1tree.html#afca5d640f5205c58695f271bea0fd8ac">More...</a><br /></td></tr>
<tr class="separator:afca5d640f5205c58695f271bea0fd8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f69f9f81a0d50355c6e47c35df54b82"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a7f69f9f81a0d50355c6e47c35df54b82">end</a> () const noexcept</td></tr>
<tr class="memdesc:a7f69f9f81a0d50355c6e47c35df54b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the element following the last element of the container.  <a href="classfcarouge_1_1tree.html#a7f69f9f81a0d50355c6e47c35df54b82">More...</a><br /></td></tr>
<tr class="separator:a7f69f9f81a0d50355c6e47c35df54b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e359d4ae6b94ab472607f15dbe3196"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a13e359d4ae6b94ab472607f15dbe3196">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a13e359d4ae6b94ab472607f15dbe3196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the element following the last element of the container.  <a href="classfcarouge_1_1tree.html#a13e359d4ae6b94ab472607f15dbe3196">More...</a><br /></td></tr>
<tr class="separator:a13e359d4ae6b94ab472607f15dbe3196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Capacity Member Functions</div></td></tr>
<tr class="memitem:a305d983d5a1a6994dee714a9f88bc1ee"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a305d983d5a1a6994dee714a9f88bc1ee">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a305d983d5a1a6994dee714a9f88bc1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements.  <a href="classfcarouge_1_1tree.html#a305d983d5a1a6994dee714a9f88bc1ee">More...</a><br /></td></tr>
<tr class="separator:a305d983d5a1a6994dee714a9f88bc1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d87b031d97d57d50ad5965585a6e79"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html#ae6cd0c0c176c23f9843dbf5f4ea5eb30">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a93d87b031d97d57d50ad5965585a6e79">size</a> () const noexcept</td></tr>
<tr class="memdesc:a93d87b031d97d57d50ad5965585a6e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container.  <a href="classfcarouge_1_1tree.html#a93d87b031d97d57d50ad5965585a6e79">More...</a><br /></td></tr>
<tr class="separator:a93d87b031d97d57d50ad5965585a6e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb88c6218835c75ee3640b98dcc4abd0"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html#ae6cd0c0c176c23f9843dbf5f4ea5eb30">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#abb88c6218835c75ee3640b98dcc4abd0">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:abb88c6218835c75ee3640b98dcc4abd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold.  <a href="classfcarouge_1_1tree.html#abb88c6218835c75ee3640b98dcc4abd0">More...</a><br /></td></tr>
<tr class="separator:abb88c6218835c75ee3640b98dcc4abd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Modifier Member Functions</div></td></tr>
<tr class="memitem:aa83d14fd7cd74b86556786b1bd0f4393"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#aa83d14fd7cd74b86556786b1bd0f4393">clear</a> () noexcept</td></tr>
<tr class="memdesc:aa83d14fd7cd74b86556786b1bd0f4393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements from the container.  <a href="classfcarouge_1_1tree.html#aa83d14fd7cd74b86556786b1bd0f4393">More...</a><br /></td></tr>
<tr class="separator:aa83d14fd7cd74b86556786b1bd0f4393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edd8fee6cbdf845fa8d765f8400fbfa"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a8edd8fee6cbdf845fa8d765f8400fbfa">insert</a> (<a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a> position, <a class="el" href="classfcarouge_1_1tree.html#abc9bb13758156a46bc7230dd86f58716">const_reference</a> value)</td></tr>
<tr class="separator:a8edd8fee6cbdf845fa8d765f8400fbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143928de819799873e2b52c5e9b58468"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a143928de819799873e2b52c5e9b58468">insert</a> (<a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a> position, <a class="el" href="classfcarouge_1_1tree.html#ad1368e9366d469e64eaf5248d7302995">value_type</a> &amp;&amp;value)</td></tr>
<tr class="separator:a143928de819799873e2b52c5e9b58468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42c67b59361f977685a6c8f00255cf2"><td class="memTemplParams" colspan="2">template&lt;class... ArgumentsType&gt; </td></tr>
<tr class="memitem:ae42c67b59361f977685a6c8f00255cf2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html#a85d21cbaae60bbcaa55f0ea7432ee293">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#ae42c67b59361f977685a6c8f00255cf2">emplace_front</a> (ArgumentsType &amp;&amp;... arguments)</td></tr>
<tr class="separator:ae42c67b59361f977685a6c8f00255cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c5f13aa881897e4acae42c4ae544e5"><td class="memTemplParams" colspan="2">template&lt;class... ArgumentsType&gt; </td></tr>
<tr class="memitem:a47c5f13aa881897e4acae42c4ae544e5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a47c5f13aa881897e4acae42c4ae544e5">emplace</a> (<a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a> position, ArgumentsType &amp;&amp;... arguments)</td></tr>
<tr class="memdesc:a47c5f13aa881897e4acae42c4ae544e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container constructed in-place directly before the <code>position</code> iterator as the new left sibling.  <a href="classfcarouge_1_1tree.html#a47c5f13aa881897e4acae42c4ae544e5">More...</a><br /></td></tr>
<tr class="separator:a47c5f13aa881897e4acae42c4ae544e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5de4a3562f0860b6250e27070fe588"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a9c5de4a3562f0860b6250e27070fe588">erase</a> (<a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a> position)</td></tr>
<tr class="memdesc:a9c5de4a3562f0860b6250e27070fe588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prunes the specified element including its sub-tree.  <a href="classfcarouge_1_1tree.html#a9c5de4a3562f0860b6250e27070fe588">More...</a><br /></td></tr>
<tr class="separator:a9c5de4a3562f0860b6250e27070fe588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae87f234bf8aef94b299b8e206b3a2e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#abae87f234bf8aef94b299b8e206b3a2e">erase</a> (<a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a> position)</td></tr>
<tr class="memdesc:abae87f234bf8aef94b299b8e206b3a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prunes the specified element including its sub-tree.  <a href="classfcarouge_1_1tree.html#abae87f234bf8aef94b299b8e206b3a2e">More...</a><br /></td></tr>
<tr class="separator:abae87f234bf8aef94b299b8e206b3a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace557ab09e595974d1250f1c8f8d0388"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#ace557ab09e595974d1250f1c8f8d0388">push</a> (<a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a> position, <a class="el" href="classfcarouge_1_1tree.html#abc9bb13758156a46bc7230dd86f58716">const_reference</a> value)</td></tr>
<tr class="memdesc:ace557ab09e595974d1250f1c8f8d0388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given element value into the container directly after the last child of the <code>position</code> iterator as the new last child.  <a href="classfcarouge_1_1tree.html#ace557ab09e595974d1250f1c8f8d0388">More...</a><br /></td></tr>
<tr class="separator:ace557ab09e595974d1250f1c8f8d0388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36c3388ad91a67e280d2ea91eb61513"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#af36c3388ad91a67e280d2ea91eb61513">push</a> (<a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a> position, <a class="el" href="classfcarouge_1_1tree.html#ad1368e9366d469e64eaf5248d7302995">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:af36c3388ad91a67e280d2ea91eb61513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given element value into the container directly after the last child of the <code>position</code> iterator as the new last child.  <a href="classfcarouge_1_1tree.html#af36c3388ad91a67e280d2ea91eb61513">More...</a><br /></td></tr>
<tr class="separator:af36c3388ad91a67e280d2ea91eb61513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7182fde5a67b4db4c3560cc59249b358"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a7182fde5a67b4db4c3560cc59249b358">push_front</a> (<a class="el" href="classfcarouge_1_1tree.html#abc9bb13758156a46bc7230dd86f58716">const_reference</a> value)</td></tr>
<tr class="memdesc:a7182fde5a67b4db4c3560cc59249b358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends the given element to the beginning of the container.  <a href="classfcarouge_1_1tree.html#a7182fde5a67b4db4c3560cc59249b358">More...</a><br /></td></tr>
<tr class="separator:a7182fde5a67b4db4c3560cc59249b358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78c82126d1345ff4d85e10ec76f674e"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#ad78c82126d1345ff4d85e10ec76f674e">push_front</a> (<a class="el" href="classfcarouge_1_1tree.html#ad1368e9366d469e64eaf5248d7302995">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:ad78c82126d1345ff4d85e10ec76f674e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends the given element to the beginning of the container.  <a href="classfcarouge_1_1tree.html#ad78c82126d1345ff4d85e10ec76f674e">More...</a><br /></td></tr>
<tr class="separator:ad78c82126d1345ff4d85e10ec76f674e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a5927fb1823432fe1a2c9105ccfa6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#aa7a5927fb1823432fe1a2c9105ccfa6f">swap</a> (<a class="el" href="classfcarouge_1_1tree.html">tree</a> &amp;other)</td></tr>
<tr class="memdesc:aa7a5927fb1823432fe1a2c9105ccfa6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of this container with those of the <code>other</code> container.  <a href="classfcarouge_1_1tree.html#aa7a5927fb1823432fe1a2c9105ccfa6f">More...</a><br /></td></tr>
<tr class="separator:aa7a5927fb1823432fe1a2c9105ccfa6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Private Member Types</div></td></tr>
<tr class="memitem:a0f58d6bc0460ce068c715672fb40a52d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a0f58d6bc0460ce068c715672fb40a52d">internal_node_allocator_type</a> = typename std::allocator_traits&lt; AllocatorType &gt;::template rebind_alloc&lt; <a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a> &gt;</td></tr>
<tr class="memdesc:a0f58d6bc0460ce068c715672fb40a52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind the allocator for the container nodes.  <a href="classfcarouge_1_1tree.html#a0f58d6bc0460ce068c715672fb40a52d">More...</a><br /></td></tr>
<tr class="separator:a0f58d6bc0460ce068c715672fb40a52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Private Modifier Member Functions</div></td></tr>
<tr class="memitem:a7118a210978495014b44c68e0df7135d"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a7118a210978495014b44c68e0df7135d">cleave</a> (<a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a> *node)</td></tr>
<tr class="memdesc:a7118a210978495014b44c68e0df7135d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Isolates the specified element including its sub-tree.  <a href="classfcarouge_1_1tree.html#a7118a210978495014b44c68e0df7135d">More...</a><br /></td></tr>
<tr class="separator:a7118a210978495014b44c68e0df7135d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e389dee96b6100d05cc0faee224f91"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a18e389dee96b6100d05cc0faee224f91">prune</a> (<a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a> *node)</td></tr>
<tr class="memdesc:a18e389dee96b6100d05cc0faee224f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively erases the specified element including its sub-tree.  <a href="classfcarouge_1_1tree.html#a18e389dee96b6100d05cc0faee224f91">More...</a><br /></td></tr>
<tr class="separator:a18e389dee96b6100d05cc0faee224f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8d9ed8c1122dd228a7392d9bd2671f"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a8b8d9ed8c1122dd228a7392d9bd2671f">axe</a> (<a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a> *node)</td></tr>
<tr class="memdesc:a8b8d9ed8c1122dd228a7392d9bd2671f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Axes the specified element including its sub-tree.  <a href="classfcarouge_1_1tree.html#a8b8d9ed8c1122dd228a7392d9bd2671f">More...</a><br /></td></tr>
<tr class="separator:a8b8d9ed8c1122dd228a7392d9bd2671f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf586baf2ec2ce3a14ae97d6e00b4471"><td class="memTemplParams" colspan="2">template&lt;class... ArgumentsType&gt; </td></tr>
<tr class="memitem:adf586baf2ec2ce3a14ae97d6e00b4471"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#adf586baf2ec2ce3a14ae97d6e00b4471">emplace_last_child</a> (<a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a> *parent, ArgumentsType &amp;&amp;... arguments)</td></tr>
<tr class="memdesc:adf586baf2ec2ce3a14ae97d6e00b4471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given element value into the container directly after the last child of the <code>position</code> iterator as the new last child.  <a href="classfcarouge_1_1tree.html#adf586baf2ec2ce3a14ae97d6e00b4471">More...</a><br /></td></tr>
<tr class="separator:adf586baf2ec2ce3a14ae97d6e00b4471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb654df3c8f35f64ce11d7bbbc8367d"><td class="memTemplParams" colspan="2">template&lt;class... ArgumentsType&gt; </td></tr>
<tr class="memitem:a9eb654df3c8f35f64ce11d7bbbc8367d"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a9eb654df3c8f35f64ce11d7bbbc8367d">emplace_root</a> (ArgumentsType &amp;&amp;... arguments)</td></tr>
<tr class="memdesc:a9eb654df3c8f35f64ce11d7bbbc8367d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends the given element to the beginning of the container.  <a href="classfcarouge_1_1tree.html#a9eb654df3c8f35f64ce11d7bbbc8367d">More...</a><br /></td></tr>
<tr class="separator:a9eb654df3c8f35f64ce11d7bbbc8367d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac95d8c0e7f379eccf5f7e9361d9c121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#aac95d8c0e7f379eccf5f7e9361d9c121">copy</a> (<a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a> *other_node, <a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a> *left_sibling, <a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a> *parent)</td></tr>
<tr class="memdesc:aac95d8c0e7f379eccf5f7e9361d9c121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the node, its subtrees, and right siblings recursively.  <a href="classfcarouge_1_1tree.html#aac95d8c0e7f379eccf5f7e9361d9c121">More...</a><br /></td></tr>
<tr class="separator:aac95d8c0e7f379eccf5f7e9361d9c121"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Private Member Variables</div></td></tr>
<tr class="memitem:a40522ac59bc82c1cfa7cae9e584116b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfcarouge_1_1tree.html#a0f58d6bc0460ce068c715672fb40a52d">internal_node_allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">node_allocator</a> {}</td></tr>
<tr class="separator:a40522ac59bc82c1cfa7cae9e584116b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c6ea7623721e3563def6f479d3c31c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a> = nullptr</td></tr>
<tr class="memdesc:a31c6ea7623721e3563def6f479d3c31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The root node of the container.  <a href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">More...</a><br /></td></tr>
<tr class="separator:a31c6ea7623721e3563def6f479d3c31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee5302eccd03bb68a5e088c0a8da489"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfcarouge_1_1tree.html#ae6cd0c0c176c23f9843dbf5f4ea5eb30">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfcarouge_1_1tree.html#a0ee5302eccd03bb68a5e088c0a8da489">node_count</a> = 0</td></tr>
<tr class="memdesc:a0ee5302eccd03bb68a5e088c0a8da489"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of elements in the container.  <a href="classfcarouge_1_1tree.html#a0ee5302eccd03bb68a5e088c0a8da489">More...</a><br /></td></tr>
<tr class="separator:a0ee5302eccd03bb68a5e088c0a8da489"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Type, class AllocatorType = std::allocator&lt;Type&gt;&gt;<br />
class fcarouge::tree&lt; Type, AllocatorType &gt;</h3>

<p>A tree data structure for C++. </p>
<p>The <a class="el" href="classfcarouge_1_1tree.html" title="A tree data structure for C++.">fcarouge::tree</a> type is a hierarchical tree data structure. The container is a non-linear non-associative unordered recursively referenced collection of nodes, each containing a value. The design tradeoffs are influenced by the Standard Template Library (STL) principles and the C++ Core Guidelines. The container is a standard layout class type which may help with memory and cross language communication. The iteration order of the standard iterator is unspecified, except that each element is visited only once.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of the contained data elements. The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type meets the requirements of Erasable, but member functions impose stricter requirements. This container (but not its members) can be instantiated with an incomplete element type if the allocator satisfies the allocator completeness requirements. </td></tr>
    <tr><td class="paramname">AllocatorType</td><td>An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. The type must meet the requirements of Allocator. The behavior is undefined if <code>Allocator::value_type</code> is not the same as <code>Type</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00072">72</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae5f330c299956045bde353a072492ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f330c299956045bde353a072492ad0">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html#ae5f330c299956045bde353a072492ad0">allocator_type</a> =  AllocatorType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the allocator for all memory allocations of this container. </p>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00083">83</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a id="a244d6ea314f6207eb38966382beb3d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244d6ea314f6207eb38966382beb3d4d">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a> =  <a class="el" href="structfcarouge_1_1tree_1_1internal__const__iterator__type.html">internal_const_iterator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant type to identify and traverse the elements of the container. </p>
<p>The iteration order of the standard constant iterator is unspecified, except that each element is visited only once. </p>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00329">329</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a id="a03614438bc62228f67b08f2eeadfa803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03614438bc62228f67b08f2eeadfa803">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html#a03614438bc62228f67b08f2eeadfa803">const_pointer</a> =  typename std::allocator_traits&lt;AllocatorType&gt;::<a class="el" href="classfcarouge_1_1tree.html#a03614438bc62228f67b08f2eeadfa803">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The const pointer type of the contained data elements. </p>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00101">101</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a id="abc9bb13758156a46bc7230dd86f58716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9bb13758156a46bc7230dd86f58716">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html#abc9bb13758156a46bc7230dd86f58716">const_reference</a> =  const <a class="el" href="classfcarouge_1_1tree.html#ad1368e9366d469e64eaf5248d7302995">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constant reference type of the contained data elements. </p>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00095">95</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a id="a8ca46de39685c48952bd45a578e3bd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca46de39685c48952bd45a578e3bd8d">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html#a8ca46de39685c48952bd45a578e3bd8d">difference_type</a> =  std::ptrdiff_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type to represent element distances. </p>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00089">89</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a id="a0f58d6bc0460ce068c715672fb40a52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f58d6bc0460ce068c715672fb40a52d">&#9670;&nbsp;</a></span>internal_node_allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html#a0f58d6bc0460ce068c715672fb40a52d">internal_node_allocator_type</a> =  typename std::allocator_traits&lt; AllocatorType&gt;::template rebind_alloc&lt;<a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rebind the allocator for the container nodes. </p>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l01090">1090</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a id="aa347e61a1909cfadea9952d73cf23b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa347e61a1909cfadea9952d73cf23b2f">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a> =  <a class="el" href="structfcarouge_1_1tree_1_1internal__iterator__type.html">internal_iterator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type to identify and traverse the elements of the container. </p>
<p>The iteration order of the standard iterator is unspecified, except that each element is visited only once. </p>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00322">322</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a id="aa318e3abfbfa6655010512a9727b7ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa318e3abfbfa6655010512a9727b7ac2">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html#aa318e3abfbfa6655010512a9727b7ac2">pointer</a> =  typename std::allocator_traits&lt;AllocatorType&gt;::<a class="el" href="classfcarouge_1_1tree.html#aa318e3abfbfa6655010512a9727b7ac2">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The pointer type of the contained data elements. </p>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00098">98</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a id="a85d21cbaae60bbcaa55f0ea7432ee293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d21cbaae60bbcaa55f0ea7432ee293">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html#a85d21cbaae60bbcaa55f0ea7432ee293">reference</a> =  <a class="el" href="classfcarouge_1_1tree.html#ad1368e9366d469e64eaf5248d7302995">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The reference type of the contained data elements. </p>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00092">92</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a id="ae6cd0c0c176c23f9843dbf5f4ea5eb30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6cd0c0c176c23f9843dbf5f4ea5eb30">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html#ae6cd0c0c176c23f9843dbf5f4ea5eb30">size_type</a> =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The unsigned integer type to represent element counts. </p>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00086">86</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<a id="ad1368e9366d469e64eaf5248d7302995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1368e9366d469e64eaf5248d7302995">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html#ad1368e9366d469e64eaf5248d7302995">value_type</a> =  Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the contained data elements. </p>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00079">79</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac28ef9d25d4cf3d18067f119eab052d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28ef9d25d4cf3d18067f119eab052d6">&#9670;&nbsp;</a></span>tree() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container with a default-constructed allocator. </p>
<dl class="section user"><dt>Complexity</dt><dd>Constant.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>Strong exception guarantees: no effect on exception. Same exceptions specification as the allocator <code>AllocatorType</code> default constructor, if any. </dd></dl>

</div>
</div>
<a id="a73f3550ee53f8886354b6ffba790a25b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f3550ee53f8886354b6ffba790a25b">&#9670;&nbsp;</a></span>tree() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramtype">const AllocatorType &amp;&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container with the given allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>Allocator to use for all memory allocations of this container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00368">368</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;          : <a class="code" href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">node_allocator</a>{ allocator }</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;  {</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;  }</div>
<div class="ttc" id="aclassfcarouge_1_1tree_html_a40522ac59bc82c1cfa7cae9e584116b3"><div class="ttname"><a href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">fcarouge::tree::node_allocator</a></div><div class="ttdeci">internal_node_allocator_type node_allocator</div><div class="ttdef"><b>Definition:</b> <a href="tree_8hpp_source.html#l01328">tree.hpp:1328</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a292f8628856bc6ac097969c8e5921cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292f8628856bc6ac097969c8e5921cab">&#9670;&nbsp;</a></span>tree() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1tree.html">tree</a>&lt; Type, AllocatorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs the container with the copy of the contents of the <code>other</code> container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Allocator is obtained as if by calling: <code>std::allocator_traits&lt;AllocatorType&gt;:: select_on_container_copy_construction(other.get_allocator())</code></dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in size of the other container. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00386">386</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;          : <a class="code" href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">node_allocator</a>{ std::allocator_traits&lt;AllocatorType&gt;::</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;                                select_on_container_copy_construction(</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;                                    other.node_allocator) },</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;            <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>{ <a class="code" href="classfcarouge_1_1tree.html#aac95d8c0e7f379eccf5f7e9361d9c121">copy</a>(other.root, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>) }, <a class="code" href="classfcarouge_1_1tree.html#a0ee5302eccd03bb68a5e088c0a8da489">node_count</a>{</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;              other.node_count</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;            }</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;  {</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;  }</div>
<div class="ttc" id="aclassfcarouge_1_1tree_html_a0ee5302eccd03bb68a5e088c0a8da489"><div class="ttname"><a href="classfcarouge_1_1tree.html#a0ee5302eccd03bb68a5e088c0a8da489">fcarouge::tree::node_count</a></div><div class="ttdeci">size_type node_count</div><div class="ttdoc">The number of elements in the container.</div><div class="ttdef"><b>Definition:</b> <a href="tree_8hpp_source.html#l01334">tree.hpp:1334</a></div></div>
<div class="ttc" id="aclassfcarouge_1_1tree_html_a31c6ea7623721e3563def6f479d3c31c"><div class="ttname"><a href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">fcarouge::tree::root</a></div><div class="ttdeci">internal_node_type * root</div><div class="ttdoc">The root node of the container.</div><div class="ttdef"><b>Definition:</b> <a href="tree_8hpp_source.html#l01331">tree.hpp:1331</a></div></div>
<div class="ttc" id="aclassfcarouge_1_1tree_html_aac95d8c0e7f379eccf5f7e9361d9c121"><div class="ttname"><a href="classfcarouge_1_1tree.html#aac95d8c0e7f379eccf5f7e9361d9c121">fcarouge::tree::copy</a></div><div class="ttdeci">internal_node_type * copy(internal_node_type *other_node, internal_node_type *left_sibling, internal_node_type *parent)</div><div class="ttdoc">Copies the node, its subtrees, and right siblings recursively.</div><div class="ttdef"><b>Definition:</b> <a href="tree_8hpp_source.html#l01297">tree.hpp:1297</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a67dc01f098aac069e73a90b84e53e3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67dc01f098aac069e73a90b84e53e3ea">&#9670;&nbsp;</a></span>tree() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1tree.html">tree</a>&lt; Type, AllocatorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AllocatorType &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator-extended copy constructor. </p>
<p>Constructs the container with the copy of the contents of the <code>other</code> container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">allocator</td><td>Allocator to use for all memory allocations of this container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in size of the other container. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00407">407</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;          : <a class="code" href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">node_allocator</a>{ allocator }, <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>{ <a class="code" href="classfcarouge_1_1tree.html#aac95d8c0e7f379eccf5f7e9361d9c121">copy</a>(other.root, <span class="keyword">nullptr</span>,</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;                                                    <span class="keyword">nullptr</span>) },</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;            <a class="code" href="classfcarouge_1_1tree.html#a0ee5302eccd03bb68a5e088c0a8da489">node_count</a>{ other.node_count }</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;  {</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af5d87b206f6c94e206ded34cf15770b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d87b206f6c94e206ded34cf15770b0">&#9670;&nbsp;</a></span>tree() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html">tree</a>&lt; Type, AllocatorType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Constructs the container with the contents of the <code>other</code> container using move semantics (i.e. the data in <code>other</code> container is moved from the other into this container). The allocator is obtained by move-construction from the allocator belonging to other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00425">425</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;          : <a class="code" href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">node_allocator</a>{ std::move(other.node_allocator) },</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;            <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>{ other.root }, <a class="code" href="classfcarouge_1_1tree.html#a0ee5302eccd03bb68a5e088c0a8da489">node_count</a>{ other.node_count }</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;  {</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    other.root = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afbf8bbfc541eb153be0051b3bab67d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf8bbfc541eb153be0051b3bab67d12">&#9670;&nbsp;</a></span>tree() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html">tree</a>&lt; Type, AllocatorType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AllocatorType &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator-extended move constructor. </p>
<p>Constructs the container with the contents of the other using move semantics (i.e. the data in <code>other</code> container is moved from the other into this container). Using the provided allocator for the new container, moving the contents from other; if <code>allocator != other.get_allocator()</code>, this results in an element-wise move.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with. </td></tr>
    <tr><td class="paramname">allocator</td><td>Allocator to use for all memory allocations of this container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00446">446</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;          : <a class="code" href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">node_allocator</a>{ allocator }, <a class="code" href="classfcarouge_1_1tree.html#a0ee5302eccd03bb68a5e088c0a8da489">node_count</a>{ other.node_count }</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;  {</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    <span class="keywordflow">if</span> (allocator != other.node_allocator) {</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;      <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a> = <a class="code" href="classfcarouge_1_1tree.html#aac95d8c0e7f379eccf5f7e9361d9c121">copy</a>(other.root, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;      <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a> = other.root;</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;      other.root = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;    }</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b968f91ee2885982251f35dee38c7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b968f91ee2885982251f35dee38c7e4">&#9670;&nbsp;</a></span>tree() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html#abc9bb13758156a46bc7230dd86f58716">const_reference</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with by copying the value for its root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to initialize elements of the container with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00462">462</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;          : <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>{ <a class="code" href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">node_allocator</a>.allocate(1) }, <a class="code" href="classfcarouge_1_1tree.html#a0ee5302eccd03bb68a5e088c0a8da489">node_count</a>{ 1 }</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;  {</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;    std::construct_at(<a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>, value);</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l01331">fcarouge::tree&lt; Type, AllocatorType &gt;::root</a>.</p>

</div>
</div>
<a id="a2ec971aec16ee59380a9e1ce1def7aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec971aec16ee59380a9e1ce1def7aa4">&#9670;&nbsp;</a></span>tree() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html#abc9bb13758156a46bc7230dd86f58716">const_reference</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AllocatorType &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with by copying the value for its root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to initialize elements of the container with. </td></tr>
    <tr><td class="paramname">allocator</td><td>Allocator to use for all memory allocations of this container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00475">475</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;          : <a class="code" href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">node_allocator</a>{ allocator }, <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>{ <a class="code" href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">node_allocator</a>.allocate(1) },</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;            <a class="code" href="classfcarouge_1_1tree.html#a0ee5302eccd03bb68a5e088c0a8da489">node_count</a>{ 1 }</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;  {</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;    std::construct_at(<a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>, value);</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l01331">fcarouge::tree&lt; Type, AllocatorType &gt;::root</a>.</p>

</div>
</div>
<a id="a710787518476c198a669d77a33c3ddf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710787518476c198a669d77a33c3ddf8">&#9670;&nbsp;</a></span>tree() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html#ad1368e9366d469e64eaf5248d7302995">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container by moving the value for its root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to initialize elements of the container with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00487">487</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;          : <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>{ <a class="code" href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">node_allocator</a>.allocate(1) }, <a class="code" href="classfcarouge_1_1tree.html#a0ee5302eccd03bb68a5e088c0a8da489">node_count</a>{ 1 }</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;  {</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;    std::construct_at(<a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>, std::move(value));</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l01331">fcarouge::tree&lt; Type, AllocatorType &gt;::root</a>.</p>

</div>
</div>
<a id="a4b14c726ea8b5aff6371f3f3f9016cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b14c726ea8b5aff6371f3f3f9016cb3">&#9670;&nbsp;</a></span>tree() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::<a class="el" href="classfcarouge_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html#ad1368e9366d469e64eaf5248d7302995">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AllocatorType &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container by moving the value for its root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to initialize elements of the container with. </td></tr>
    <tr><td class="paramname">allocator</td><td>Allocator to use for all memory allocations of this container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00500">500</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;          : <a class="code" href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">node_allocator</a>{ allocator }, <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>{ <a class="code" href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">node_allocator</a>.allocate(1) },</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;            <a class="code" href="classfcarouge_1_1tree.html#a0ee5302eccd03bb68a5e088c0a8da489">node_count</a>{ 1 }</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;  {</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;    std::construct_at(<a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>, std::move(value));</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l01331">fcarouge::tree&lt; Type, AllocatorType &gt;::root</a>.</p>

</div>
</div>
<a id="a3e97ce6cb6385676b59aae76e18fef31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e97ce6cb6385676b59aae76e18fef31">&#9670;&nbsp;</a></span>~tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::~<a class="el" href="classfcarouge_1_1tree.html">tree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructs the container. </p>
<p>The destructors of the elements are called and the used storage is deallocated.</p>
<dl class="section note"><dt>Note</dt><dd>If the elements are pointers, the pointed-to objects are not destroyed.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the size of the container.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>The exception specification needs to be confirmed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00518">518</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;  {</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;    <a class="code" href="classfcarouge_1_1tree.html#a8b8d9ed8c1122dd228a7392d9bd2671f">axe</a>(<a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>);</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;  }</div>
<div class="ttc" id="aclassfcarouge_1_1tree_html_a8b8d9ed8c1122dd228a7392d9bd2671f"><div class="ttname"><a href="classfcarouge_1_1tree.html#a8b8d9ed8c1122dd228a7392d9bd2671f">fcarouge::tree::axe</a></div><div class="ttdeci">constexpr void axe(internal_node_type *node)</div><div class="ttdoc">Axes the specified element including its sub-tree.</div><div class="ttdef"><b>Definition:</b> <a href="tree_8hpp_source.html#l01159">tree.hpp:1159</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l01159">fcarouge::tree&lt; Type, AllocatorType &gt;::axe()</a>, and <a class="el" href="tree_8hpp_source.html#l01331">fcarouge::tree&lt; Type, AllocatorType &gt;::root</a>.</p>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classfcarouge_1_1tree_a3e97ce6cb6385676b59aae76e18fef31_cgraph.png" border="0" usemap="#aclassfcarouge_1_1tree_a3e97ce6cb6385676b59aae76e18fef31_cgraph" alt=""/></div>
<map name="aclassfcarouge_1_1tree_a3e97ce6cb6385676b59aae76e18fef31_cgraph" id="aclassfcarouge_1_1tree_a3e97ce6cb6385676b59aae76e18fef31_cgraph">
<area shape="rect" title="Destructs the container." alt="" coords="5,5,140,32"/>
<area shape="rect" href="classfcarouge_1_1tree.html#a8b8d9ed8c1122dd228a7392d9bd2671f" title="Axes the specified element including its sub&#45;tree." alt="" coords="188,5,315,32"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afa2adeaaf61d4ec87bf58d22689fa7aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2adeaaf61d4ec87bf58d22689fa7aa">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html">tree</a>&amp; <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1tree.html">tree</a>&lt; Type, AllocatorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f2f4cb1caf5a71e1a298ab6e5460955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2f4cb1caf5a71e1a298ab6e5460955">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html">tree</a>&amp; <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html#abc9bb13758156a46bc7230dd86f58716">const_reference</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f15335a7dcc09697cb4a64507547b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f15335a7dcc09697cb4a64507547b9a">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html">tree</a>&amp; <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html">tree</a>&lt; Type, AllocatorType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abdd1f973e74cfbed19867a43e700b0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd1f973e74cfbed19867a43e700b0ba">&#9670;&nbsp;</a></span>assign() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html">tree</a>&amp; <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html#ad1368e9366d469e64eaf5248d7302995">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b8d9ed8c1122dd228a7392d9bd2671f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8d9ed8c1122dd228a7392d9bd2671f">&#9670;&nbsp;</a></span>axe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::axe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Axes the specified element including its sub-tree. </p>
<p>Removes the <code>node</code> element and prune its associated sub-tree. References and iterators to the erased elements are invalidated. Other references and iterators are not affected. The container's size is not maintained and no longer corresponds to the container content.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The pointer to the element to erase. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l01159">1159</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;  {</div>
<div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;    <span class="keywordflow">if</span> (node) {</div>
<div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;      <a class="code" href="classfcarouge_1_1tree.html#a8b8d9ed8c1122dd228a7392d9bd2671f">axe</a>(node-&gt;first_child);</div>
<div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;      <a class="code" href="classfcarouge_1_1tree.html#a8b8d9ed8c1122dd228a7392d9bd2671f">axe</a>(node-&gt;right_sibling);</div>
<div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160; </div>
<div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;      std::destroy_at(node);</div>
<div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;      <a class="code" href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">node_allocator</a>.deallocate(node, 1);</div>
<div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;    }</div>
<div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l00148">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::first_child</a>, <a class="el" href="tree_8hpp_source.html#l01328">fcarouge::tree&lt; Type, AllocatorType &gt;::node_allocator</a>, and <a class="el" href="tree_8hpp_source.html#l00151">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::right_sibling</a>.</p>

<p class="reference">Referenced by <a class="el" href="tree_8hpp_source.html#l00797">fcarouge::tree&lt; Type, AllocatorType &gt;::clear()</a>, and <a class="el" href="tree_8hpp_source.html#l00518">fcarouge::tree&lt; Type, AllocatorType &gt;::~tree()</a>.</p>
<div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classfcarouge_1_1tree_a8b8d9ed8c1122dd228a7392d9bd2671f_icgraph.png" border="0" usemap="#aclassfcarouge_1_1tree_a8b8d9ed8c1122dd228a7392d9bd2671f_icgraph" alt=""/></div>
<map name="aclassfcarouge_1_1tree_a8b8d9ed8c1122dd228a7392d9bd2671f_icgraph" id="aclassfcarouge_1_1tree_a8b8d9ed8c1122dd228a7392d9bd2671f_icgraph">
<area shape="rect" title="Axes the specified element including its sub&#45;tree." alt="" coords="188,31,315,57"/>
<area shape="rect" href="classfcarouge_1_1tree.html#aa83d14fd7cd74b86556786b1bd0f4393" title="Erases all elements from the container." alt="" coords="5,5,140,32"/>
<area shape="rect" href="classfcarouge_1_1tree.html#a3e97ce6cb6385676b59aae76e18fef31" title="Destructs the container." alt="" coords="5,56,140,83"/>
</map>
</div>

</div>
</div>
<a id="a4986566354e05a0d3f8b263799e42e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4986566354e05a0d3f8b263799e42e45">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a> <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the first element of the container. </p>
<p>If the container is empty, the returned constant iterator will be equal to <code><a class="el" href="classfcarouge_1_1tree.html#afca5d640f5205c58695f271bea0fd8ac" title="Returns an iterator to the element following the last element of the container.">end()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Constant iterator to the first element.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00675">675</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;  {</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;    <span class="keywordflow">return</span> { <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a> };</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l01331">fcarouge::tree&lt; Type, AllocatorType &gt;::root</a>.</p>

</div>
</div>
<a id="a217fb2d8d248bedec9126214e8c891a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217fb2d8d248bedec9126214e8c891a2">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a> <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<p>If the container is empty, the returned iterator will be equal to <code><a class="el" href="classfcarouge_1_1tree.html#afca5d640f5205c58695f271bea0fd8ac" title="Returns an iterator to the element following the last element of the container.">end()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00662">662</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;  {</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;    <span class="keywordflow">return</span> { <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a> };</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l01331">fcarouge::tree&lt; Type, AllocatorType &gt;::root</a>.</p>

</div>
</div>
<a id="a4d914f8d4ce69f0ecd580e7ddb5d16d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d914f8d4ce69f0ecd580e7ddb5d16d1">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a> <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the first element of the container. </p>
<p>If the container is empty, the returned constant iterator will be equal to <code><a class="el" href="classfcarouge_1_1tree.html#afca5d640f5205c58695f271bea0fd8ac" title="Returns an iterator to the element following the last element of the container.">end()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Constant iterator to the first element.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00688">688</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;  {</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;    <span class="keywordflow">return</span> { <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a> };</div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l01331">fcarouge::tree&lt; Type, AllocatorType &gt;::root</a>.</p>

</div>
</div>
<a id="a13e359d4ae6b94ab472607f15dbe3196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e359d4ae6b94ab472607f15dbe3196">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a> <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the element following the last element of the container. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior. If the container is empty, the returned constant iterator will be equal to <code><a class="el" href="classfcarouge_1_1tree.html#a217fb2d8d248bedec9126214e8c891a2" title="Returns an iterator to the first element of the container.">begin()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Constant iterator to the element following the last element.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00733">733</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;  {</div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;    <span class="keywordflow">return</span> { <span class="keyword">nullptr</span> };</div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa83d14fd7cd74b86556786b1bd0f4393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa83d14fd7cd74b86556786b1bd0f4393">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements from the container. </p>
<p>After this call, the size member function calls returns zero. Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterator remains valid.</p>
<dl class="section user"><dt>Complexity</dt><dd>Linear in size of this container, i.e., the number of elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00797">797</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;  {</div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;    <a class="code" href="classfcarouge_1_1tree.html#a8b8d9ed8c1122dd228a7392d9bd2671f">axe</a>(<a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>);</div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;    <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a> = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;    <a class="code" href="classfcarouge_1_1tree.html#a0ee5302eccd03bb68a5e088c0a8da489">node_count</a> = 0;</div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l01159">fcarouge::tree&lt; Type, AllocatorType &gt;::axe()</a>, <a class="el" href="tree_8hpp_source.html#l01334">fcarouge::tree&lt; Type, AllocatorType &gt;::node_count</a>, and <a class="el" href="tree_8hpp_source.html#l01331">fcarouge::tree&lt; Type, AllocatorType &gt;::root</a>.</p>
<div id="dynsection-3" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-3-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classfcarouge_1_1tree_aa83d14fd7cd74b86556786b1bd0f4393_cgraph.png" border="0" usemap="#aclassfcarouge_1_1tree_aa83d14fd7cd74b86556786b1bd0f4393_cgraph" alt=""/></div>
<map name="aclassfcarouge_1_1tree_aa83d14fd7cd74b86556786b1bd0f4393_cgraph" id="aclassfcarouge_1_1tree_aa83d14fd7cd74b86556786b1bd0f4393_cgraph">
<area shape="rect" title="Erases all elements from the container." alt="" coords="5,5,140,32"/>
<area shape="rect" href="classfcarouge_1_1tree.html#a8b8d9ed8c1122dd228a7392d9bd2671f" title="Axes the specified element including its sub&#45;tree." alt="" coords="188,5,315,32"/>
</map>
</div>

</div>
</div>
<a id="a7118a210978495014b44c68e0df7135d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7118a210978495014b44c68e0df7135d">&#9670;&nbsp;</a></span>cleave()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::cleave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Isolates the specified element including its sub-tree. </p>
<p>Orphans the node from its parent and disolve its sibling relationships. The container's size is not maintained and no longer corresponds to the container content. Cleaving the root or last node has the expected effects on the tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The pointer to the element to cleave. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l01106">1106</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;  {</div>
<div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;    <span class="keywordflow">if</span> (node == <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>) {</div>
<div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;      <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a> = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;    }</div>
<div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;    <span class="keywordflow">if</span> (node-&gt;parent) {</div>
<div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;      <span class="keywordflow">if</span> (node-&gt;parent-&gt;first_child == node) {</div>
<div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;        node-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#abb38b1b9d4f98d6e22d6e88797e6c4d2">parent</a>-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a44c6ec9ad486992afdc8a06595c30091">first_child</a> = node-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a50654e62b5fb8488e4e13502e64dd428">right_sibling</a>;</div>
<div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;      }</div>
<div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;      <span class="keywordflow">if</span> (node-&gt;parent-&gt;last_child == node) {</div>
<div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;        node-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#abb38b1b9d4f98d6e22d6e88797e6c4d2">parent</a>-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a9a54ad63c8a20e3a1a845a7ae1355762">last_child</a> = node-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a7ca1b6727ae12b6bd30d5f8208e548f3">left_sibling</a>;</div>
<div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;      }</div>
<div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;    }</div>
<div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;    <span class="keywordflow">if</span> (node-&gt;left_sibling) {</div>
<div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;      node-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a7ca1b6727ae12b6bd30d5f8208e548f3">left_sibling</a>-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a50654e62b5fb8488e4e13502e64dd428">right_sibling</a> = node-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a50654e62b5fb8488e4e13502e64dd428">right_sibling</a>;</div>
<div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;      node-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a7ca1b6727ae12b6bd30d5f8208e548f3">left_sibling</a> = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;    }</div>
<div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;    <span class="keywordflow">if</span> (node-&gt;right_sibling) {</div>
<div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;      node-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a50654e62b5fb8488e4e13502e64dd428">right_sibling</a>-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a7ca1b6727ae12b6bd30d5f8208e548f3">left_sibling</a> = node-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a7ca1b6727ae12b6bd30d5f8208e548f3">left_sibling</a>;</div>
<div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;      node-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a50654e62b5fb8488e4e13502e64dd428">right_sibling</a> = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;    }</div>
<div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;  }</div>
<div class="ttc" id="astructfcarouge_1_1tree_1_1internal__node__type_html_a44c6ec9ad486992afdc8a06595c30091"><div class="ttname"><a href="structfcarouge_1_1tree_1_1internal__node__type.html#a44c6ec9ad486992afdc8a06595c30091">fcarouge::tree::internal_node_type::first_child</a></div><div class="ttdeci">internal_node_type * first_child</div><div class="ttdef"><b>Definition:</b> <a href="tree_8hpp_source.html#l00148">tree.hpp:148</a></div></div>
<div class="ttc" id="astructfcarouge_1_1tree_1_1internal__node__type_html_a50654e62b5fb8488e4e13502e64dd428"><div class="ttname"><a href="structfcarouge_1_1tree_1_1internal__node__type.html#a50654e62b5fb8488e4e13502e64dd428">fcarouge::tree::internal_node_type::right_sibling</a></div><div class="ttdeci">internal_node_type * right_sibling</div><div class="ttdef"><b>Definition:</b> <a href="tree_8hpp_source.html#l00151">tree.hpp:151</a></div></div>
<div class="ttc" id="astructfcarouge_1_1tree_1_1internal__node__type_html_a7ca1b6727ae12b6bd30d5f8208e548f3"><div class="ttname"><a href="structfcarouge_1_1tree_1_1internal__node__type.html#a7ca1b6727ae12b6bd30d5f8208e548f3">fcarouge::tree::internal_node_type::left_sibling</a></div><div class="ttdeci">internal_node_type * left_sibling</div><div class="ttdef"><b>Definition:</b> <a href="tree_8hpp_source.html#l00150">tree.hpp:150</a></div></div>
<div class="ttc" id="astructfcarouge_1_1tree_1_1internal__node__type_html_a9a54ad63c8a20e3a1a845a7ae1355762"><div class="ttname"><a href="structfcarouge_1_1tree_1_1internal__node__type.html#a9a54ad63c8a20e3a1a845a7ae1355762">fcarouge::tree::internal_node_type::last_child</a></div><div class="ttdeci">internal_node_type * last_child</div><div class="ttdef"><b>Definition:</b> <a href="tree_8hpp_source.html#l00149">tree.hpp:149</a></div></div>
<div class="ttc" id="astructfcarouge_1_1tree_1_1internal__node__type_html_abb38b1b9d4f98d6e22d6e88797e6c4d2"><div class="ttname"><a href="structfcarouge_1_1tree_1_1internal__node__type.html#abb38b1b9d4f98d6e22d6e88797e6c4d2">fcarouge::tree::internal_node_type::parent</a></div><div class="ttdeci">internal_node_type * parent</div><div class="ttdef"><b>Definition:</b> <a href="tree_8hpp_source.html#l00152">tree.hpp:152</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l00148">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::first_child</a>, <a class="el" href="tree_8hpp_source.html#l00149">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::last_child</a>, <a class="el" href="tree_8hpp_source.html#l00150">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::left_sibling</a>, <a class="el" href="tree_8hpp_source.html#l00152">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::parent</a>, <a class="el" href="tree_8hpp_source.html#l00151">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::right_sibling</a>, and <a class="el" href="tree_8hpp_source.html#l01331">fcarouge::tree&lt; Type, AllocatorType &gt;::root</a>.</p>

<p class="reference">Referenced by <a class="el" href="tree_8hpp_source.html#l00910">fcarouge::tree&lt; Type, AllocatorType &gt;::erase()</a>.</p>
<div id="dynsection-4" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-4-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-4-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-4-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classfcarouge_1_1tree_a7118a210978495014b44c68e0df7135d_icgraph.png" border="0" usemap="#aclassfcarouge_1_1tree_a7118a210978495014b44c68e0df7135d_icgraph" alt=""/></div>
<map name="aclassfcarouge_1_1tree_a7118a210978495014b44c68e0df7135d_icgraph" id="aclassfcarouge_1_1tree_a7118a210978495014b44c68e0df7135d_icgraph">
<area shape="rect" title="Isolates the specified element including its sub&#45;tree." alt="" coords="192,5,336,32"/>
<area shape="rect" href="classfcarouge_1_1tree.html#a9c5de4a3562f0860b6250e27070fe588" title="Prunes the specified element including its sub&#45;tree." alt="" coords="5,5,144,32"/>
</map>
</div>

</div>
</div>
<a id="aac95d8c0e7f379eccf5f7e9361d9c121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac95d8c0e7f379eccf5f7e9361d9c121">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a>* <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a> *&#160;</td>
          <td class="paramname"><em>other_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a> *&#160;</td>
          <td class="paramname"><em>left_sibling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the node, its subtrees, and right siblings recursively. </p>
<p>Constructs a new node from the <code>other_node</code> element value. Attaches the newly created child to its parent, if any. Attaches the newly created right sibling to its left sibling, if any.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_node</td><td>The other tree node to copy. </td></tr>
    <tr><td class="paramname">left_sibling</td><td>The optional left sibling node to attach this new node to. </td></tr>
    <tr><td class="paramname">parent</td><td>The optional parent node to attach this new node to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the size of the number of nodes copied. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l01297">1297</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;  {</div>
<div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;    <span class="comment">// If there is another node to copy...</span></div>
<div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;    <span class="keywordflow">if</span> (other_node) {</div>
<div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;      <span class="comment">// ...allocate and in-place construct a node with this container&#39;s</span></div>
<div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;      <span class="comment">// allocator, the other node data value, and any left sibling or parent</span></div>
<div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;      <span class="comment">// pointers...</span></div>
<div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;      internal_node_type *node = <a class="code" href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">node_allocator</a>.allocate(1);</div>
<div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;      std::construct_at(node, other_node-&gt;data, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>, left_sibling,</div>
<div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;                        <span class="keyword">nullptr</span>, parent);</div>
<div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;      <span class="comment">// ...recursively copy the right sibling and first child passing in left</span></div>
<div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;      <span class="comment">// sibling and parent pointers...</span></div>
<div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;      node-&gt;right_sibling = <a class="code" href="classfcarouge_1_1tree.html#aac95d8c0e7f379eccf5f7e9361d9c121">copy</a>(other_node-&gt;right_sibling, node, node-&gt;parent);</div>
<div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;      node-&gt;first_child = <a class="code" href="classfcarouge_1_1tree.html#aac95d8c0e7f379eccf5f7e9361d9c121">copy</a>(other_node-&gt;first_child, <span class="keyword">nullptr</span>, node);</div>
<div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;      <span class="comment">// ...reference the parent&#39;s last child with the last right sibling.</span></div>
<div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;      <span class="keywordflow">if</span> (node-&gt;parent &amp;&amp; !node-&gt;parent-&gt;last_child) {</div>
<div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;        node-&gt;parent-&gt;last_child = node;</div>
<div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;      }</div>
<div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;      <span class="keywordflow">return</span> node;</div>
<div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;    }</div>
<div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160; </div>
<div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l00147">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::data</a>, <a class="el" href="tree_8hpp_source.html#l00148">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::first_child</a>, <a class="el" href="tree_8hpp_source.html#l00149">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::last_child</a>, <a class="el" href="tree_8hpp_source.html#l01328">fcarouge::tree&lt; Type, AllocatorType &gt;::node_allocator</a>, <a class="el" href="tree_8hpp_source.html#l00152">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::parent</a>, and <a class="el" href="tree_8hpp_source.html#l00151">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::right_sibling</a>.</p>

</div>
</div>
<a id="a47c5f13aa881897e4acae42c4ae544e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c5f13aa881897e4acae42c4ae544e5">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... ArgumentsType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a> <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgumentsType &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container constructed in-place directly before the <code>position</code> iterator as the new left sibling. </p>
<p>The element is constructed through <code>std::allocator_traits::construct</code>, which typically uses placement-new to construct the element in-place at a location provided by the container. The <code>arguments</code> are forwarded to the constructor as <code>std::forward&lt;ArgumentsType&gt;(arguments)...</code>. No iterators or references are invalidated. Inserts at the root position as the new root. Inserts before the beginning <code><a class="el" href="classfcarouge_1_1tree.html#a217fb2d8d248bedec9126214e8c891a2" title="Returns an iterator to the first element of the container.">begin()</a></code> position as the new root. Inserts before the ending <code><a class="el" href="classfcarouge_1_1tree.html#afca5d640f5205c58695f271bea0fd8ac" title="Returns an iterator to the element following the last element of the container.">end()</a></code> position.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArgumentsType</td><td>The argument types to forward to the constructor of the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The constant iterator before which the new element will be constructed. The iterator may be the beginning <code><a class="el" href="classfcarouge_1_1tree.html#a217fb2d8d248bedec9126214e8c891a2" title="Returns an iterator to the first element of the container.">begin()</a></code> or ending <code><a class="el" href="classfcarouge_1_1tree.html#afca5d640f5205c58695f271bea0fd8ac" title="Returns an iterator to the element following the last element of the container.">end()</a></code> iterator. </td></tr>
    <tr><td class="paramname">arguments</td><td>The arguments to forward to the constructor of the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator pointing to the inserted element.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00836">836</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;  {</div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;    <span class="comment">// The allocated node is in-place construced and recorded in every</span></div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;    <span class="comment">// following statements.</span></div>
<div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;    internal_node_type *node = <a class="code" href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">node_allocator</a>.allocate(1);</div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160; </div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;    <span class="comment">// Insert the new node...</span></div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;    <span class="comment">// ...before the position node...</span></div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;    <span class="keywordflow">if</span> (internal_node_type *position_node = position.node) {</div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;      <span class="comment">// ...as the new left child...</span></div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;      <span class="keywordflow">if</span> (position_node-&gt;parent) {</div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;        std::construct_at(node, std::forward&lt;ArgumentsType&gt;(arguments)...,</div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;                          <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>, position_node-&gt;left_sibling,</div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;                          position_node, position_node-&gt;parent);</div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;        position_node-&gt;left_sibling = node;</div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;        <span class="comment">// ...with a left sibling node.</span></div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;        <span class="keywordflow">if</span> (internal_node_type *left_node = node-&gt;left_sibling) {</div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;          left_node-&gt;right_sibling = node;</div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;        }</div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;        <span class="comment">// ...without a left sibling node.</span></div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;        <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;          position_node-&gt;parent-&gt;first_child = node;</div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;        }</div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;      }</div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;      <span class="comment">// ...as the new root.</span></div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;      <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;        std::construct_at(node, std::forward&lt;ArgumentsType&gt;(arguments)...,</div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;                          position_node, position_node);</div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;        position_node-&gt;parent = node;</div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;        <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a> = node;</div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;      }</div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;    }</div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;    <span class="comment">// ...as the new last node...</span></div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;    <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;      <span class="comment">// ... as the last child of the root node.</span></div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>) {</div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;        std::construct_at(node, std::forward&lt;ArgumentsType&gt;(arguments)...,</div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;                          <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>, <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a9a54ad63c8a20e3a1a845a7ae1355762">last_child</a>, <span class="keyword">nullptr</span>, <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>);</div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;        <span class="keywordflow">if</span> (!<a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a44c6ec9ad486992afdc8a06595c30091">first_child</a>) {</div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;          <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a44c6ec9ad486992afdc8a06595c30091">first_child</a> = node;</div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;        }</div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a9a54ad63c8a20e3a1a845a7ae1355762">last_child</a>) {</div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;          <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a9a54ad63c8a20e3a1a845a7ae1355762">last_child</a>-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a50654e62b5fb8488e4e13502e64dd428">right_sibling</a> = node;</div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;        }</div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;        <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a9a54ad63c8a20e3a1a845a7ae1355762">last_child</a> = node;</div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;      }</div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;      <span class="comment">// ...as the sole, and root node.</span></div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;      <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;        std::construct_at(node, std::forward&lt;ArgumentsType&gt;(arguments)...);</div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;        <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a> = node;</div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;      }</div>
<div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;    }</div>
<div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160; </div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;    ++<a class="code" href="classfcarouge_1_1tree.html#a0ee5302eccd03bb68a5e088c0a8da489">node_count</a>;</div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;    <span class="keywordflow">return</span> { node };</div>
<div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l00148">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::first_child</a>, <a class="el" href="tree_8hpp_source.html#l00149">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::last_child</a>, <a class="el" href="tree_8hpp_source.html#l00150">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::left_sibling</a>, <a class="el" href="tree_8hpp_source.html#l00309">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_const_iterator_type::node</a>, <a class="el" href="tree_8hpp_source.html#l01328">fcarouge::tree&lt; Type, AllocatorType &gt;::node_allocator</a>, <a class="el" href="tree_8hpp_source.html#l01334">fcarouge::tree&lt; Type, AllocatorType &gt;::node_count</a>, <a class="el" href="tree_8hpp_source.html#l00152">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::parent</a>, <a class="el" href="tree_8hpp_source.html#l00151">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::right_sibling</a>, and <a class="el" href="tree_8hpp_source.html#l01331">fcarouge::tree&lt; Type, AllocatorType &gt;::root</a>.</p>

</div>
</div>
<a id="ae42c67b59361f977685a6c8f00255cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae42c67b59361f977685a6c8f00255cf2">&#9670;&nbsp;</a></span>emplace_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... ArgumentsType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html#a85d21cbaae60bbcaa55f0ea7432ee293">reference</a> <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">ArgumentsType &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adf586baf2ec2ce3a14ae97d6e00b4471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf586baf2ec2ce3a14ae97d6e00b4471">&#9670;&nbsp;</a></span>emplace_last_child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... ArgumentsType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a>* <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::emplace_last_child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgumentsType &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given element value into the container directly after the last child of the <code>position</code> iterator as the new last child. </p>
<p>No iterators or references are invalidated. The new element is in-place constructed and moved, or copied. Inserts after the beginning <code><a class="el" href="classfcarouge_1_1tree.html#a217fb2d8d248bedec9126214e8c891a2" title="Returns an iterator to the first element of the container.">begin()</a></code> position as the last child of the root if present, or as the root if the container is empty. Inserts after the ending <code><a class="el" href="classfcarouge_1_1tree.html#afca5d640f5205c58695f271bea0fd8ac" title="Returns an iterator to the element following the last element of the container.">end()</a></code> position as the sole child of the last node if present, or as the root if the container is empty.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArgumentsType</td><td>The argument types to forward to the constructor of the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent node for which the element will be inserted as the last child. Emplacing a node without a parent places the node at the end. </td></tr>
    <tr><td class="paramname">arguments</td><td>The construction data of the element to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator pointing to the inserted element.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>Strong exception guarantees: no effect on exception. The <code>Allocator::allocate()</code> allocation or the element copy/move constructor/assignment may throw. If <code>Type</code>'s move constructor is not <code>noexcept</code> and <code>Type</code> is not CopyInsertable into <code>*this</code>, the container will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l01199">1199</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;  {</div>
<div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;    <span class="comment">// The allocated child node is in-place construced and recorded in every</span></div>
<div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;    <span class="comment">// following statements.</span></div>
<div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;    internal_node_type *child = <a class="code" href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">node_allocator</a>.allocate(1);</div>
<div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160; </div>
<div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;    <span class="comment">// Insert the new node...</span></div>
<div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;    <span class="comment">// ...as the last child of the position node...</span></div>
<div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;    <span class="keywordflow">if</span> (parent) {</div>
<div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;      std::construct_at(child, std::forward&lt;ArgumentsType&gt;(arguments)...,</div>
<div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;                        <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>, parent-&gt;last_child, <span class="keyword">nullptr</span>, parent);</div>
<div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;      parent-&gt;last_child = child;</div>
<div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160; </div>
<div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;      <span class="comment">// ...with a left sibling node.</span></div>
<div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;      <span class="keywordflow">if</span> (child-&gt;left_sibling) {</div>
<div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;        child-&gt;left_sibling-&gt;right_sibling = child;</div>
<div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;      }</div>
<div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;      <span class="comment">// ...without a left sibling node.</span></div>
<div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;      <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;        parent-&gt;first_child = child;</div>
<div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;        <span class="comment">// ...whose parent was the last node...</span></div>
<div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;      }</div>
<div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;    }</div>
<div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;    <span class="comment">// ...as the new last node...</span></div>
<div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;    <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;      <span class="comment">// ... as the last child of the root node.</span></div>
<div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>) {</div>
<div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;        std::construct_at(child, std::forward&lt;ArgumentsType&gt;(arguments)...,</div>
<div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;                          <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>, <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a9a54ad63c8a20e3a1a845a7ae1355762">last_child</a>, <span class="keyword">nullptr</span>, <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>);</div>
<div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;        <span class="keywordflow">if</span> (!<a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a44c6ec9ad486992afdc8a06595c30091">first_child</a>) {</div>
<div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;          <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a44c6ec9ad486992afdc8a06595c30091">first_child</a> = child;</div>
<div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;        }</div>
<div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a9a54ad63c8a20e3a1a845a7ae1355762">last_child</a>) {</div>
<div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;          <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a9a54ad63c8a20e3a1a845a7ae1355762">last_child</a>-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a50654e62b5fb8488e4e13502e64dd428">right_sibling</a> = child;</div>
<div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;        }</div>
<div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;        <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a9a54ad63c8a20e3a1a845a7ae1355762">last_child</a> = child;</div>
<div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;      }</div>
<div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;      <span class="comment">// ...as the sole, and root node.</span></div>
<div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;      <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;        std::construct_at(child, std::forward&lt;ArgumentsType&gt;(arguments)...);</div>
<div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;        <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a> = child;</div>
<div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;      }</div>
<div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;    }</div>
<div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160; </div>
<div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;    ++<a class="code" href="classfcarouge_1_1tree.html#a0ee5302eccd03bb68a5e088c0a8da489">node_count</a>;</div>
<div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160; </div>
<div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;    <span class="keywordflow">return</span> child;</div>
<div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l00148">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::first_child</a>, <a class="el" href="tree_8hpp_source.html#l00149">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::last_child</a>, <a class="el" href="tree_8hpp_source.html#l00150">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::left_sibling</a>, <a class="el" href="tree_8hpp_source.html#l01328">fcarouge::tree&lt; Type, AllocatorType &gt;::node_allocator</a>, <a class="el" href="tree_8hpp_source.html#l01334">fcarouge::tree&lt; Type, AllocatorType &gt;::node_count</a>, <a class="el" href="tree_8hpp_source.html#l00151">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::right_sibling</a>, and <a class="el" href="tree_8hpp_source.html#l01331">fcarouge::tree&lt; Type, AllocatorType &gt;::root</a>.</p>

<p class="reference">Referenced by <a class="el" href="tree_8hpp_source.html#l00980">fcarouge::tree&lt; Type, AllocatorType &gt;::push()</a>.</p>
<div id="dynsection-5" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-5-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-5-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-5-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classfcarouge_1_1tree_adf586baf2ec2ce3a14ae97d6e00b4471_icgraph.png" border="0" usemap="#aclassfcarouge_1_1tree_adf586baf2ec2ce3a14ae97d6e00b4471_icgraph" alt=""/></div>
<map name="aclassfcarouge_1_1tree_adf586baf2ec2ce3a14ae97d6e00b4471_icgraph" id="aclassfcarouge_1_1tree_adf586baf2ec2ce3a14ae97d6e00b4471_icgraph">
<area shape="rect" title="Inserts the given element value into the container directly after the last child of the position iter..." alt="" coords="188,5,343,47"/>
<area shape="rect" href="classfcarouge_1_1tree.html#ace557ab09e595974d1250f1c8f8d0388" title="Inserts the given element value into the container directly after the last child of the position iter..." alt="" coords="5,13,140,39"/>
</map>
</div>

</div>
</div>
<a id="a9eb654df3c8f35f64ce11d7bbbc8367d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb654df3c8f35f64ce11d7bbbc8367d">&#9670;&nbsp;</a></span>emplace_root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... ArgumentsType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::emplace_root </td>
          <td>(</td>
          <td class="paramtype">ArgumentsType &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepends the given element to the beginning of the container. </p>
<p>Prepends the given element as the new root. If the container is not empty the root becomes the sole child of the prepended element. No iterators or references are invalidated. The new element is in-place constructed and moved, or copied.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArgumentsType</td><td>The argument types to forward to the constructor of the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arguments</td><td>The construction data of the element to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>Strong exception guarantees: no effect on exception. The <code>Allocator::allocate()</code> allocation or the element copy/move constructor/assignment may throw. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l01266">1266</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;  {</div>
<div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;    <span class="comment">// The allocated node is in-place construced and recorded in every</span></div>
<div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;    <span class="comment">// following statements.</span></div>
<div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;    internal_node_type *node = <a class="code" href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">node_allocator</a>.allocate(1);</div>
<div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160; </div>
<div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;    <span class="comment">// Insert the new node and prepare it to be the new root...</span></div>
<div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;    std::construct_at(node, std::forward&lt;ArgumentsType&gt;(arguments)..., <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>,</div>
<div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;                      <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>);</div>
<div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160; </div>
<div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;    <span class="comment">// ... by displacing the previous root.</span></div>
<div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>) {</div>
<div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;      <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#abb38b1b9d4f98d6e22d6e88797e6c4d2">parent</a> = node;</div>
<div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;    }</div>
<div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;    <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a> = node;</div>
<div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160; </div>
<div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;    ++<a class="code" href="classfcarouge_1_1tree.html#a0ee5302eccd03bb68a5e088c0a8da489">node_count</a>;</div>
<div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l01328">fcarouge::tree&lt; Type, AllocatorType &gt;::node_allocator</a>, <a class="el" href="tree_8hpp_source.html#l01334">fcarouge::tree&lt; Type, AllocatorType &gt;::node_count</a>, <a class="el" href="tree_8hpp_source.html#l00152">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::parent</a>, and <a class="el" href="tree_8hpp_source.html#l01331">fcarouge::tree&lt; Type, AllocatorType &gt;::root</a>.</p>

<p class="reference">Referenced by <a class="el" href="tree_8hpp_source.html#l01036">fcarouge::tree&lt; Type, AllocatorType &gt;::push_front()</a>.</p>
<div id="dynsection-6" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-6-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-6-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-6-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classfcarouge_1_1tree_a9eb654df3c8f35f64ce11d7bbbc8367d_icgraph.png" border="0" usemap="#aclassfcarouge_1_1tree_a9eb654df3c8f35f64ce11d7bbbc8367d_icgraph" alt=""/></div>
<map name="aclassfcarouge_1_1tree_a9eb654df3c8f35f64ce11d7bbbc8367d_icgraph" id="aclassfcarouge_1_1tree_a9eb654df3c8f35f64ce11d7bbbc8367d_icgraph">
<area shape="rect" title="Prepends the given element to the beginning of the container." alt="" coords="188,13,372,39"/>
<area shape="rect" href="classfcarouge_1_1tree.html#a7182fde5a67b4db4c3560cc59249b358" title="Prepends the given element to the beginning of the container." alt="" coords="5,5,140,47"/>
</map>
</div>

</div>
</div>
<a id="a305d983d5a1a6994dee714a9f88bc1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305d983d5a1a6994dee714a9f88bc1ee">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container has no elements. </p>
<p>Whether the beginning iterator equals the ending iterator.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the container is empty, false otherwise.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00750">750</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;  {</div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classfcarouge_1_1tree.html#a0ee5302eccd03bb68a5e088c0a8da489">node_count</a> == 0;</div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l01334">fcarouge::tree&lt; Type, AllocatorType &gt;::node_count</a>.</p>

</div>
</div>
<a id="a7f69f9f81a0d50355c6e47c35df54b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f69f9f81a0d50355c6e47c35df54b82">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a> <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the element following the last element of the container. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior. If the container is empty, the returned constant iterator will be equal to <code><a class="el" href="classfcarouge_1_1tree.html#a217fb2d8d248bedec9126214e8c891a2" title="Returns an iterator to the first element of the container.">begin()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Constant iterator to the element following the last element.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00718">718</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;  {</div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;    <span class="keywordflow">return</span> { <span class="keyword">nullptr</span> };</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afca5d640f5205c58695f271bea0fd8ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca5d640f5205c58695f271bea0fd8ac">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a> <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<p>This element acts as a placeholder; attempting to access it results in undefined behavior. If the container is empty, the returned constant iterator will be equal to <code><a class="el" href="classfcarouge_1_1tree.html#a217fb2d8d248bedec9126214e8c891a2" title="Returns an iterator to the first element of the container.">begin()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00703">703</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;  {</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;    <span class="keywordflow">return</span> { <span class="keyword">nullptr</span> };</div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abae87f234bf8aef94b299b8e206b3a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae87f234bf8aef94b299b8e206b3a2e">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a> <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prunes the specified element including its sub-tree. </p>
<p>Removes the element at <code>position</code> and prune its associated sub-tree. References and iterators to the erased elements are invalidated. Other references and iterators are not affected. The iterator <code>position</code> must be valid and dereferenceable. Thus the <code><a class="el" href="classfcarouge_1_1tree.html#afca5d640f5205c58695f271bea0fd8ac" title="Returns an iterator to the element following the last element of the container.">end()</a></code> iterator which is valid, but is not dereferenceable cannot be used as a value for <code>position</code>. The same is applicable for the <code><a class="el" href="classfcarouge_1_1tree.html#a217fb2d8d248bedec9126214e8c891a2" title="Returns an iterator to the first element of the container.">begin()</a></code> iterator on an empty container. The container's size is reduded by the number of elements removed, that is the node and all nodes in its sub-tree. If the erased node is the root, the tree is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The constant iterator to the element to remove with its subtree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. If <code>position</code> refers to the last element, then the <code><a class="el" href="classfcarouge_1_1tree.html#afca5d640f5205c58695f271bea0fd8ac" title="Returns an iterator to the element following the last element of the container.">end()</a></code> iterator is returned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00938">938</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;  {</div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;    <span class="comment">// Identify the node following this subtree which will become the next node,</span></div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;    <span class="comment">// separate the subtree out of the tree, and recursively erase the subtree.</span></div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;    internal_node_type *next{ position.node-&gt;next_ancestor_sibling() };</div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;    <a class="code" href="classfcarouge_1_1tree.html#a7118a210978495014b44c68e0df7135d">cleave</a>(position.node);</div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;    <a class="code" href="classfcarouge_1_1tree.html#a18e389dee96b6100d05cc0faee224f91">prune</a>(position.node);</div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160; </div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;    <span class="keywordflow">return</span> { next };</div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;  }</div>
<div class="ttc" id="aclassfcarouge_1_1tree_html_a18e389dee96b6100d05cc0faee224f91"><div class="ttname"><a href="classfcarouge_1_1tree.html#a18e389dee96b6100d05cc0faee224f91">fcarouge::tree::prune</a></div><div class="ttdeci">constexpr void prune(internal_node_type *node)</div><div class="ttdoc">Recursively erases the specified element including its sub-tree.</div><div class="ttdef"><b>Definition:</b> <a href="tree_8hpp_source.html#l01138">tree.hpp:1138</a></div></div>
<div class="ttc" id="aclassfcarouge_1_1tree_html_a7118a210978495014b44c68e0df7135d"><div class="ttname"><a href="classfcarouge_1_1tree.html#a7118a210978495014b44c68e0df7135d">fcarouge::tree::cleave</a></div><div class="ttdeci">constexpr void cleave(internal_node_type *node)</div><div class="ttdoc">Isolates the specified element including its sub-tree.</div><div class="ttdef"><b>Definition:</b> <a href="tree_8hpp_source.html#l01106">tree.hpp:1106</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l01106">fcarouge::tree&lt; Type, AllocatorType &gt;::cleave()</a>, <a class="el" href="tree_8hpp_source.html#l00129">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::next_ancestor_sibling()</a>, <a class="el" href="tree_8hpp_source.html#l00309">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_const_iterator_type::node</a>, and <a class="el" href="tree_8hpp_source.html#l01138">fcarouge::tree&lt; Type, AllocatorType &gt;::prune()</a>.</p>
<div id="dynsection-7" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-7-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-7-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-7-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classfcarouge_1_1tree_abae87f234bf8aef94b299b8e206b3a2e_cgraph.png" border="0" usemap="#aclassfcarouge_1_1tree_abae87f234bf8aef94b299b8e206b3a2e_cgraph" alt=""/></div>
<map name="aclassfcarouge_1_1tree_abae87f234bf8aef94b299b8e206b3a2e_cgraph" id="aclassfcarouge_1_1tree_abae87f234bf8aef94b299b8e206b3a2e_cgraph">
<area shape="rect" title="Prunes the specified element including its sub&#45;tree." alt="" coords="5,95,144,121"/>
<area shape="rect" href="classfcarouge_1_1tree.html#a7118a210978495014b44c68e0df7135d" title="Isolates the specified element including its sub&#45;tree." alt="" coords="207,5,351,32"/>
<area shape="rect" href="structfcarouge_1_1tree_1_1internal__node__type.html#ad267c5ade8dd24d9baae39cb5eaae27f" title="Finds the nearest right sibling of itself or ancestor." alt="" coords="192,80,367,136"/>
<area shape="rect" href="classfcarouge_1_1tree.html#a18e389dee96b6100d05cc0faee224f91" title="Recursively erases the specified element including its sub&#45;tree." alt="" coords="210,160,349,187"/>
</map>
</div>

</div>
</div>
<a id="a9c5de4a3562f0860b6250e27070fe588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5de4a3562f0860b6250e27070fe588">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a> <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prunes the specified element including its sub-tree. </p>
<p>Removes the element at <code>position</code> and prune its associated sub-tree. References and iterators to the erased elements are invalidated. Other references and iterators are not affected. The iterator <code>position</code> must be valid and dereferenceable. Thus the <code><a class="el" href="classfcarouge_1_1tree.html#afca5d640f5205c58695f271bea0fd8ac" title="Returns an iterator to the element following the last element of the container.">end()</a></code> iterator which is valid, but is not dereferenceable cannot be used as a value for <code>position</code>. The same is applicable for the <code><a class="el" href="classfcarouge_1_1tree.html#a217fb2d8d248bedec9126214e8c891a2" title="Returns an iterator to the first element of the container.">begin()</a></code> iterator on an empty container. The container's size is reduded by the number of elements removed, that is the node and all nodes in its sub-tree. If the erased node is the root, the tree is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The iterator to the element to remove with its subtree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. If <code>position</code> refers to the last element, then the <code><a class="el" href="classfcarouge_1_1tree.html#afca5d640f5205c58695f271bea0fd8ac" title="Returns an iterator to the element following the last element of the container.">end()</a></code> iterator is returned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00910">910</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;  {</div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;    <span class="comment">// Identify the node following this subtree which will become the next node,</span></div>
<div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;    <span class="comment">// separate the subtree out of the tree, and recursively erase the subtree.</span></div>
<div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;    internal_node_type *next{ position.node-&gt;next_ancestor_sibling() };</div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;    <a class="code" href="classfcarouge_1_1tree.html#a7118a210978495014b44c68e0df7135d">cleave</a>(position.node);</div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;    <a class="code" href="classfcarouge_1_1tree.html#a18e389dee96b6100d05cc0faee224f91">prune</a>(position.node);</div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160; </div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;    <span class="keywordflow">return</span> { next };</div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l01106">fcarouge::tree&lt; Type, AllocatorType &gt;::cleave()</a>, <a class="el" href="tree_8hpp_source.html#l00129">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::next_ancestor_sibling()</a>, <a class="el" href="tree_8hpp_source.html#l00214">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_iterator_type::node</a>, and <a class="el" href="tree_8hpp_source.html#l01138">fcarouge::tree&lt; Type, AllocatorType &gt;::prune()</a>.</p>
<div id="dynsection-8" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-8-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-8-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-8-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classfcarouge_1_1tree_a9c5de4a3562f0860b6250e27070fe588_cgraph.png" border="0" usemap="#aclassfcarouge_1_1tree_a9c5de4a3562f0860b6250e27070fe588_cgraph" alt=""/></div>
<map name="aclassfcarouge_1_1tree_a9c5de4a3562f0860b6250e27070fe588_cgraph" id="aclassfcarouge_1_1tree_a9c5de4a3562f0860b6250e27070fe588_cgraph">
<area shape="rect" title="Prunes the specified element including its sub&#45;tree." alt="" coords="5,95,144,121"/>
<area shape="rect" href="classfcarouge_1_1tree.html#a7118a210978495014b44c68e0df7135d" title="Isolates the specified element including its sub&#45;tree." alt="" coords="207,5,351,32"/>
<area shape="rect" href="structfcarouge_1_1tree_1_1internal__node__type.html#ad267c5ade8dd24d9baae39cb5eaae27f" title="Finds the nearest right sibling of itself or ancestor." alt="" coords="192,80,367,136"/>
<area shape="rect" href="classfcarouge_1_1tree.html#a18e389dee96b6100d05cc0faee224f91" title="Recursively erases the specified element including its sub&#45;tree." alt="" coords="210,160,349,187"/>
</map>
</div>

</div>
</div>
<a id="a1452f7fc3685dd1e35314f1488f04693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1452f7fc3685dd1e35314f1488f04693">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html#a85d21cbaae60bbcaa55f0ea7432ee293">reference</a> <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<p>Calling front on an empty container causes undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For a non-empty container <code>c</code>, the expression <code>c.front()</code> is equivalent to <code>*c.<a class="el" href="classfcarouge_1_1tree.html#a217fb2d8d248bedec9126214e8c891a2" title="Returns an iterator to the first element of the container.">begin()</a></code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00628">628</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;  {</div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a0678b7a0857922263963001b0b7e70bc">data</a>;</div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;  }</div>
<div class="ttc" id="astructfcarouge_1_1tree_1_1internal__node__type_html_a0678b7a0857922263963001b0b7e70bc"><div class="ttname"><a href="structfcarouge_1_1tree_1_1internal__node__type.html#a0678b7a0857922263963001b0b7e70bc">fcarouge::tree::internal_node_type::data</a></div><div class="ttdeci">value_type data</div><div class="ttdef"><b>Definition:</b> <a href="tree_8hpp_source.html#l00147">tree.hpp:147</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l00147">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::data</a>, and <a class="el" href="tree_8hpp_source.html#l01331">fcarouge::tree&lt; Type, AllocatorType &gt;::root</a>.</p>

</div>
</div>
<a id="a27dfcb2f1ab3f3f1f2d12c78fa416241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27dfcb2f1ab3f3f1f2d12c78fa416241">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html#abc9bb13758156a46bc7230dd86f58716">const_reference</a> <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the first element in the container. </p>
<p>Calling front on an empty container causes undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Constant reference to the first element.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For a non-empty container <code>c</code>, the expression <code>c.front()</code> is equivalent to <code>*c.<a class="el" href="classfcarouge_1_1tree.html#a217fb2d8d248bedec9126214e8c891a2" title="Returns an iterator to the first element of the container.">begin()</a></code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00644">644</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;  {</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a>-&gt;<a class="code" href="structfcarouge_1_1tree_1_1internal__node__type.html#a0678b7a0857922263963001b0b7e70bc">data</a>;</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l00147">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::data</a>, and <a class="el" href="tree_8hpp_source.html#l01331">fcarouge::tree&lt; Type, AllocatorType &gt;::root</a>.</p>

</div>
</div>
<a id="a9c65db35e938093e6b0a210630f1d84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c65db35e938093e6b0a210630f1d84d">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html#ae5f330c299956045bde353a072492ad0">allocator_type</a> <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated allocator.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00608">608</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;  {</div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">node_allocator</a>;</div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l01328">fcarouge::tree&lt; Type, AllocatorType &gt;::node_allocator</a>.</p>

</div>
</div>
<a id="a8edd8fee6cbdf845fa8d765f8400fbfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8edd8fee6cbdf845fa8d765f8400fbfa">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a> <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html#abc9bb13758156a46bc7230dd86f58716">const_reference</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a143928de819799873e2b52c5e9b58468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a143928de819799873e2b52c5e9b58468">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a> <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html#ad1368e9366d469e64eaf5248d7302995">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb88c6218835c75ee3640b98dcc4abd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb88c6218835c75ee3640b98dcc4abd0">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html#ae6cd0c0c176c23f9843dbf5f4ea5eb30">size_type</a> <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the container is able to hold. </p>
<p>The maximum number of elements depends on the system or library implementation limitations. The absolute distance between the beginning and end iterators for the largest container.</p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of elements.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This value typically reflects the theoretical limit on the size of the container, at most <code>std:: numeric_limits&lt;difference_type&gt;:: max()</code>. At runtime, the size of the container may be limited to a value smaller than <a class="el" href="classfcarouge_1_1tree.html#abb88c6218835c75ee3640b98dcc4abd0" title="Returns the maximum number of elements the container is able to hold.">max_size()</a> by the amount of RAM available. </dd></dl>

</div>
</div>
<a id="a6b2887816b7f092fc401938e669d70b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2887816b7f092fc401938e669d70b4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html">tree</a>&amp; <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfcarouge_1_1tree.html">tree</a>&lt; Type, AllocatorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p>Destroys or copy-assigns the contents with a copy of the contents of the other container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference value of this implicit object container parameter, i.e. <code>*this</code>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the size of this and the other container. </dd></dl>

</div>
</div>
<a id="a0cdcdfb8c62a8753e1c3ad3c21f604eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdcdfb8c62a8753e1c3ad3c21f604eb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html">tree</a>&amp; <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html#abc9bb13758156a46bc7230dd86f58716">const_reference</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value copy assignment operator. </p>
<p>Replaces the contents with a copy of the contents of the value for its root.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to initialize the container with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference value of this implicit object container parameter, i.e. <code>*this</code>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Linear in the size of this and the other container. </dd></dl>

</div>
</div>
<a id="aacc33736760cfa53031240e46cb57e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc33736760cfa53031240e46cb57e4a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html">tree</a>&amp; <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html">tree</a>&lt; Type, AllocatorType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<p>Replaces the contents with those of the <code>other</code> container using move semantics (i.e. the data in <code>other</code> container is moved from the other into this container). The other container is in a valid but unspecified state afterwards. The allocator is obtained by move-construction from the allocator belonging to other. Self move assignement is valid, safe, and meet specifications.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference value of this implicit object container parameter, i.e. <code>*this</code>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>Same exceptions specification as the allocator <code>AllocatorType</code> move assignment operator, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00556">556</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;  {</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">this</span> != std::addressof(other)) {</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;      <a class="code" href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">node_allocator</a> = std::move(other.node_allocator);</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;      <a class="code" href="classfcarouge_1_1tree.html#a31c6ea7623721e3563def6f479d3c31c">root</a> = other.root;</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;      <a class="code" href="classfcarouge_1_1tree.html#a0ee5302eccd03bb68a5e088c0a8da489">node_count</a> = other.node_count;</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;      other.root = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;    }</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l01328">fcarouge::tree&lt; Type, AllocatorType &gt;::node_allocator</a>, <a class="el" href="tree_8hpp_source.html#l01334">fcarouge::tree&lt; Type, AllocatorType &gt;::node_count</a>, and <a class="el" href="tree_8hpp_source.html#l01331">fcarouge::tree&lt; Type, AllocatorType &gt;::root</a>.</p>

</div>
</div>
<a id="a98bd9c0bba29aff00363a210996ba14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98bd9c0bba29aff00363a210996ba14c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html">tree</a>&amp; <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html#ad1368e9366d469e64eaf5248d7302995">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value move assignment operator. </p>
<p>Replaces the contents with those of the value using move semantics (i.e. the value data is moved into the root of this container). The value is in a valid but unspecified state afterwards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to initialize the container with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference value of this implicit object container parameter, i.e. <code>*this</code>.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="a18e389dee96b6100d05cc0faee224f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e389dee96b6100d05cc0faee224f91">&#9670;&nbsp;</a></span>prune()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::prune </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively erases the specified element including its sub-tree. </p>
<p>Removes the <code>node</code> element and prune its associated sub-tree. References and iterators to the erased elements are invalidated. Other references and iterators are not affected. The container's size is reduded by the number of elements removed, that is the node and all nodes in its sub-tree. If the erased node is the root, the tree is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The pointer to the element to erase. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l01138">1138</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;  {</div>
<div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;    <span class="keywordflow">if</span> (node) {</div>
<div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;      <a class="code" href="classfcarouge_1_1tree.html#a18e389dee96b6100d05cc0faee224f91">prune</a>(node-&gt;first_child);</div>
<div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;      <a class="code" href="classfcarouge_1_1tree.html#a18e389dee96b6100d05cc0faee224f91">prune</a>(node-&gt;right_sibling);</div>
<div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160; </div>
<div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;      std::destroy_at(node);</div>
<div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;      <a class="code" href="classfcarouge_1_1tree.html#a40522ac59bc82c1cfa7cae9e584116b3">node_allocator</a>.deallocate(node, 1);</div>
<div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160; </div>
<div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;      --<a class="code" href="classfcarouge_1_1tree.html#a0ee5302eccd03bb68a5e088c0a8da489">node_count</a>;</div>
<div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;    }</div>
<div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l00148">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::first_child</a>, <a class="el" href="tree_8hpp_source.html#l01328">fcarouge::tree&lt; Type, AllocatorType &gt;::node_allocator</a>, <a class="el" href="tree_8hpp_source.html#l01334">fcarouge::tree&lt; Type, AllocatorType &gt;::node_count</a>, and <a class="el" href="tree_8hpp_source.html#l00151">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_node_type::right_sibling</a>.</p>

<p class="reference">Referenced by <a class="el" href="tree_8hpp_source.html#l00910">fcarouge::tree&lt; Type, AllocatorType &gt;::erase()</a>.</p>
<div id="dynsection-9" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-9-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-9-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-9-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classfcarouge_1_1tree_a18e389dee96b6100d05cc0faee224f91_icgraph.png" border="0" usemap="#aclassfcarouge_1_1tree_a18e389dee96b6100d05cc0faee224f91_icgraph" alt=""/></div>
<map name="aclassfcarouge_1_1tree_a18e389dee96b6100d05cc0faee224f91_icgraph" id="aclassfcarouge_1_1tree_a18e389dee96b6100d05cc0faee224f91_icgraph">
<area shape="rect" title="Recursively erases the specified element including its sub&#45;tree." alt="" coords="192,5,331,32"/>
<area shape="rect" href="classfcarouge_1_1tree.html#a9c5de4a3562f0860b6250e27070fe588" title="Prunes the specified element including its sub&#45;tree." alt="" coords="5,5,144,32"/>
</map>
</div>

</div>
</div>
<a id="ace557ab09e595974d1250f1c8f8d0388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace557ab09e595974d1250f1c8f8d0388">&#9670;&nbsp;</a></span>push() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a> <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html#abc9bb13758156a46bc7230dd86f58716">const_reference</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given element value into the container directly after the last child of the <code>position</code> iterator as the new last child. </p>
<p>No iterators or references are invalidated. The new element is initialized as a copy of <code>value</code>. <code>Type</code> must meet the CopyInsertable requirement to use this overload. Inserts after the beginning <code><a class="el" href="classfcarouge_1_1tree.html#a217fb2d8d248bedec9126214e8c891a2" title="Returns an iterator to the first element of the container.">begin()</a></code> position as the last child of the root if present, or as the root if the container is empty. Inserts after the ending <code><a class="el" href="classfcarouge_1_1tree.html#afca5d640f5205c58695f271bea0fd8ac" title="Returns an iterator to the element following the last element of the container.">end()</a></code> position as the sole child of the last node if present, or as the root if the container is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The parent node constant iterator for which the element will be inserted as the last child. The iterator may be the beginning <code><a class="el" href="classfcarouge_1_1tree.html#a217fb2d8d248bedec9126214e8c891a2" title="Returns an iterator to the first element of the container.">begin()</a></code> or ending <code><a class="el" href="classfcarouge_1_1tree.html#afca5d640f5205c58695f271bea0fd8ac" title="Returns an iterator to the element following the last element of the container.">end()</a></code> iterator. </td></tr>
    <tr><td class="paramname">value</td><td>The data of the element to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator pointing to the inserted element.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>Strong exception guarantees: no effect on exception. The <code>Allocator::allocate()</code> allocation or the element copy/move constructor/assignment may throw. If <code>Type</code>'s move constructor is not <code>noexcept</code> and <code>Type</code> is not CopyInsertable into <code>*this</code>, the container will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This <code>push</code> modifier method definition is not represented in the Standard Template Library (STL) containers. The presence of the modifier is justified from the non-linear nature of the container in addition to the consistency claim with <code>insert</code> and <code>emplace</code> modifier method definitions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00980">980</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;  {</div>
<div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;    <span class="keywordflow">return</span> { <a class="code" href="classfcarouge_1_1tree.html#adf586baf2ec2ce3a14ae97d6e00b4471">emplace_last_child</a>(position.node, value) };</div>
<div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;  }</div>
<div class="ttc" id="aclassfcarouge_1_1tree_html_adf586baf2ec2ce3a14ae97d6e00b4471"><div class="ttname"><a href="classfcarouge_1_1tree.html#adf586baf2ec2ce3a14ae97d6e00b4471">fcarouge::tree::emplace_last_child</a></div><div class="ttdeci">constexpr internal_node_type * emplace_last_child(internal_node_type *parent, ArgumentsType &amp;&amp;... arguments)</div><div class="ttdoc">Inserts the given element value into the container directly after the last child of the position iter...</div><div class="ttdef"><b>Definition:</b> <a href="tree_8hpp_source.html#l01199">tree.hpp:1199</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l01199">fcarouge::tree&lt; Type, AllocatorType &gt;::emplace_last_child()</a>, and <a class="el" href="tree_8hpp_source.html#l00309">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_const_iterator_type::node</a>.</p>
<div id="dynsection-10" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-10-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-10-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-10-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classfcarouge_1_1tree_ace557ab09e595974d1250f1c8f8d0388_cgraph.png" border="0" usemap="#aclassfcarouge_1_1tree_ace557ab09e595974d1250f1c8f8d0388_cgraph" alt=""/></div>
<map name="aclassfcarouge_1_1tree_ace557ab09e595974d1250f1c8f8d0388_cgraph" id="aclassfcarouge_1_1tree_ace557ab09e595974d1250f1c8f8d0388_cgraph">
<area shape="rect" title="Inserts the given element value into the container directly after the last child of the position iter..." alt="" coords="5,13,140,39"/>
<area shape="rect" href="classfcarouge_1_1tree.html#adf586baf2ec2ce3a14ae97d6e00b4471" title="Inserts the given element value into the container directly after the last child of the position iter..." alt="" coords="188,5,343,47"/>
</map>
</div>

</div>
</div>
<a id="af36c3388ad91a67e280d2ea91eb61513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36c3388ad91a67e280d2ea91eb61513">&#9670;&nbsp;</a></span>push() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html#aa347e61a1909cfadea9952d73cf23b2f">iterator</a> <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html#a244d6ea314f6207eb38966382beb3d4d">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html#ad1368e9366d469e64eaf5248d7302995">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given element value into the container directly after the last child of the <code>position</code> iterator as the new last child. </p>
<p>No iterators or references are invalidated. The new element is initialized with a move of <code>value</code>. <code>Type</code> must meet the MoveInsertable requirement to use this overload. Inserts after the beginning <code><a class="el" href="classfcarouge_1_1tree.html#a217fb2d8d248bedec9126214e8c891a2" title="Returns an iterator to the first element of the container.">begin()</a></code> position as the last child of the root if present, or as the root if the container is empty. Inserts after the ending <code><a class="el" href="classfcarouge_1_1tree.html#afca5d640f5205c58695f271bea0fd8ac" title="Returns an iterator to the element following the last element of the container.">end()</a></code> position as the sole child of the last node if present, or as the root if the container is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The parent node constant iterator for which the element will be inserted as the last child. The iterator may be the beginning <code><a class="el" href="classfcarouge_1_1tree.html#a217fb2d8d248bedec9126214e8c891a2" title="Returns an iterator to the first element of the container.">begin()</a></code> or ending <code><a class="el" href="classfcarouge_1_1tree.html#afca5d640f5205c58695f271bea0fd8ac" title="Returns an iterator to the element following the last element of the container.">end()</a></code> iterator. </td></tr>
    <tr><td class="paramname">value</td><td>The data of the element to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator pointing to the inserted element.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>Strong exception guarantees: no effect on exception. The <code>Allocator::allocate()</code> allocation or the element copy/move constructor/assignment may throw.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This <code>push</code> modifier method definition is not represented in the Standard Template Library (STL) containers. The presence of the modifier is justified from the non-linear nature of the container in addition to the consistency claim with <code>insert</code> and <code>emplace</code> modifier method definitions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l01012">1012</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;  {</div>
<div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;    <span class="keywordflow">return</span> { <a class="code" href="classfcarouge_1_1tree.html#adf586baf2ec2ce3a14ae97d6e00b4471">emplace_last_child</a>(position.node, std::move(value)) };</div>
<div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l01199">fcarouge::tree&lt; Type, AllocatorType &gt;::emplace_last_child()</a>, and <a class="el" href="tree_8hpp_source.html#l00309">fcarouge::tree&lt; Type, AllocatorType &gt;::internal_const_iterator_type::node</a>.</p>
<div id="dynsection-11" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-11-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-11-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-11-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classfcarouge_1_1tree_af36c3388ad91a67e280d2ea91eb61513_cgraph.png" border="0" usemap="#aclassfcarouge_1_1tree_af36c3388ad91a67e280d2ea91eb61513_cgraph" alt=""/></div>
<map name="aclassfcarouge_1_1tree_af36c3388ad91a67e280d2ea91eb61513_cgraph" id="aclassfcarouge_1_1tree_af36c3388ad91a67e280d2ea91eb61513_cgraph">
<area shape="rect" title="Inserts the given element value into the container directly after the last child of the position iter..." alt="" coords="5,13,140,39"/>
<area shape="rect" href="classfcarouge_1_1tree.html#adf586baf2ec2ce3a14ae97d6e00b4471" title="Inserts the given element value into the container directly after the last child of the position iter..." alt="" coords="188,5,343,47"/>
</map>
</div>

</div>
</div>
<a id="a7182fde5a67b4db4c3560cc59249b358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7182fde5a67b4db4c3560cc59249b358">&#9670;&nbsp;</a></span>push_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html#abc9bb13758156a46bc7230dd86f58716">const_reference</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepends the given element to the beginning of the container. </p>
<p>Prepends the given element as the new root. If the container is not empty the root becomes the sole child of the prepended element. No iterators or references are invalidated. The new element is initialized as a copy of <code>value</code>. <code>Type</code> must meet the CopyInsertable requirement to use this overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The data of the element to prepend.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>Strong exception guarantees: no effect on exception. The <code>Allocator::allocate()</code> allocation or the element copy/move constructor/assignment may throw. If <code>Type</code>'s move constructor is not <code>noexcept</code> and <code>Type</code> is not CopyInsertable into <code>*this</code>, the container will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l01036">1036</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;  {</div>
<div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;    <a class="code" href="classfcarouge_1_1tree.html#a9eb654df3c8f35f64ce11d7bbbc8367d">emplace_root</a>(value);</div>
<div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;  }</div>
<div class="ttc" id="aclassfcarouge_1_1tree_html_a9eb654df3c8f35f64ce11d7bbbc8367d"><div class="ttname"><a href="classfcarouge_1_1tree.html#a9eb654df3c8f35f64ce11d7bbbc8367d">fcarouge::tree::emplace_root</a></div><div class="ttdeci">constexpr void emplace_root(ArgumentsType &amp;&amp;... arguments)</div><div class="ttdoc">Prepends the given element to the beginning of the container.</div><div class="ttdef"><b>Definition:</b> <a href="tree_8hpp_source.html#l01266">tree.hpp:1266</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l01266">fcarouge::tree&lt; Type, AllocatorType &gt;::emplace_root()</a>.</p>
<div id="dynsection-12" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-12-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-12-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-12-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classfcarouge_1_1tree_a7182fde5a67b4db4c3560cc59249b358_cgraph.png" border="0" usemap="#aclassfcarouge_1_1tree_a7182fde5a67b4db4c3560cc59249b358_cgraph" alt=""/></div>
<map name="aclassfcarouge_1_1tree_a7182fde5a67b4db4c3560cc59249b358_cgraph" id="aclassfcarouge_1_1tree_a7182fde5a67b4db4c3560cc59249b358_cgraph">
<area shape="rect" title="Prepends the given element to the beginning of the container." alt="" coords="5,5,140,47"/>
<area shape="rect" href="classfcarouge_1_1tree.html#a9eb654df3c8f35f64ce11d7bbbc8367d" title="Prepends the given element to the beginning of the container." alt="" coords="188,13,372,39"/>
</map>
</div>

</div>
</div>
<a id="ad78c82126d1345ff4d85e10ec76f674e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78c82126d1345ff4d85e10ec76f674e">&#9670;&nbsp;</a></span>push_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html#ad1368e9366d469e64eaf5248d7302995">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepends the given element to the beginning of the container. </p>
<p>Prepends the given element as the new root. If the container is not empty the root becomes the sole child of the prepended element. No iterators or references are invalidated. The new element is initialized with a move of <code>value</code>. <code>Type</code> must meet the MoveInsertable requirement to use this overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The data of the element to prepend.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant.</dd></dl>
<dl class="section user"><dt>Exceptions</dt><dd>Strong exception guarantees: no effect on exception. The <code>Allocator::allocate()</code> allocation or the element copy/move constructor/assignment may throw. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l01056">1056</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;  {</div>
<div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;    <a class="code" href="classfcarouge_1_1tree.html#a9eb654df3c8f35f64ce11d7bbbc8367d">emplace_root</a>(std::move(value));</div>
<div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l01266">fcarouge::tree&lt; Type, AllocatorType &gt;::emplace_root()</a>.</p>
<div id="dynsection-13" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-13-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-13-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-13-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classfcarouge_1_1tree_ad78c82126d1345ff4d85e10ec76f674e_cgraph.png" border="0" usemap="#aclassfcarouge_1_1tree_ad78c82126d1345ff4d85e10ec76f674e_cgraph" alt=""/></div>
<map name="aclassfcarouge_1_1tree_ad78c82126d1345ff4d85e10ec76f674e_cgraph" id="aclassfcarouge_1_1tree_ad78c82126d1345ff4d85e10ec76f674e_cgraph">
<area shape="rect" title="Prepends the given element to the beginning of the container." alt="" coords="5,5,140,47"/>
<area shape="rect" href="classfcarouge_1_1tree.html#a9eb654df3c8f35f64ce11d7bbbc8367d" title="Prepends the given element to the beginning of the container." alt="" coords="188,13,372,39"/>
</map>
</div>

</div>
</div>
<a id="a93d87b031d97d57d50ad5965585a6e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d87b031d97d57d50ad5965585a6e79">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classfcarouge_1_1tree.html#ae6cd0c0c176c23f9843dbf5f4ea5eb30">size_type</a> <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container. </p>
<p>The absolute distance between the beginning and end iterators.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l00762">762</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;  {</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classfcarouge_1_1tree.html#a0ee5302eccd03bb68a5e088c0a8da489">node_count</a>;</div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="tree_8hpp_source.html#l01334">fcarouge::tree&lt; Type, AllocatorType &gt;::node_count</a>.</p>

<p class="reference">Referenced by <a class="el" href="tree_8hpp_source.html#l01357">operator==()</a>.</p>
<div id="dynsection-14" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-14-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-14-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-14-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classfcarouge_1_1tree_a93d87b031d97d57d50ad5965585a6e79_icgraph.png" border="0" usemap="#aclassfcarouge_1_1tree_a93d87b031d97d57d50ad5965585a6e79_icgraph" alt=""/></div>
<map name="aclassfcarouge_1_1tree_a93d87b031d97d57d50ad5965585a6e79_icgraph" id="aclassfcarouge_1_1tree_a93d87b031d97d57d50ad5965585a6e79_icgraph">
<area shape="rect" title="Returns the number of elements in the container." alt="" coords="139,5,268,32"/>
<area shape="rect" href="tree_8hpp.html#ae617bea810be26e335a2cc2e2c91d3e8" title="Compares the contents of two containers." alt="" coords="5,5,91,32"/>
</map>
</div>

</div>
</div>
<a id="aa7a5927fb1823432fe1a2c9105ccfa6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a5927fb1823432fe1a2c9105ccfa6f">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfcarouge_1_1tree.html">tree</a>&lt; Type, AllocatorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchanges the contents of this container with those of the <code>other</code> container. </p>
<p>Does not invoke any move, copy, or swap operations on individual elements. All iterators and references remain valid. The <code>Compare</code> objects must be Swappable, and they are exchanged using unqualified call to non-member swap. If <code>std:: allocator_traits&lt;allocator_type&gt;:: propagate_on_container_swap:: value</code> is <code>true</code>, then the allocators are exchanged using an unqualified call to non-member swap. Otherwise, they are not swapped (and if <code><a class="el" href="classfcarouge_1_1tree.html#a9c65db35e938093e6b0a210630f1d84d" title="Returns the allocator associated with the container.">get_allocator()</a> != other.get_allocator()</code>, the behavior is undefined).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The container to exchange the contents with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity</dt><dd>Constant.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Iterators and references referring to an element in a container before the swap refers to the same element in the other container afterwards. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a40522ac59bc82c1cfa7cae9e584116b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40522ac59bc82c1cfa7cae9e584116b3">&#9670;&nbsp;</a></span>node_allocator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfcarouge_1_1tree.html#a0f58d6bc0460ce068c715672fb40a52d">internal_node_allocator_type</a> <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::node_allocator {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l01328">1328</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="tree_8hpp_source.html#l01159">fcarouge::tree&lt; Type, AllocatorType &gt;::axe()</a>, <a class="el" href="tree_8hpp_source.html#l01297">fcarouge::tree&lt; Type, AllocatorType &gt;::copy()</a>, <a class="el" href="tree_8hpp_source.html#l00836">fcarouge::tree&lt; Type, AllocatorType &gt;::emplace()</a>, <a class="el" href="tree_8hpp_source.html#l01199">fcarouge::tree&lt; Type, AllocatorType &gt;::emplace_last_child()</a>, <a class="el" href="tree_8hpp_source.html#l01266">fcarouge::tree&lt; Type, AllocatorType &gt;::emplace_root()</a>, <a class="el" href="tree_8hpp_source.html#l00608">fcarouge::tree&lt; Type, AllocatorType &gt;::get_allocator()</a>, <a class="el" href="tree_8hpp_source.html#l00556">fcarouge::tree&lt; Type, AllocatorType &gt;::operator=()</a>, and <a class="el" href="tree_8hpp_source.html#l01138">fcarouge::tree&lt; Type, AllocatorType &gt;::prune()</a>.</p>

</div>
</div>
<a id="a0ee5302eccd03bb68a5e088c0a8da489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee5302eccd03bb68a5e088c0a8da489">&#9670;&nbsp;</a></span>node_count</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfcarouge_1_1tree.html#ae6cd0c0c176c23f9843dbf5f4ea5eb30">size_type</a> <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::node_count = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of elements in the container. </p>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l01334">1334</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="tree_8hpp_source.html#l00797">fcarouge::tree&lt; Type, AllocatorType &gt;::clear()</a>, <a class="el" href="tree_8hpp_source.html#l00836">fcarouge::tree&lt; Type, AllocatorType &gt;::emplace()</a>, <a class="el" href="tree_8hpp_source.html#l01199">fcarouge::tree&lt; Type, AllocatorType &gt;::emplace_last_child()</a>, <a class="el" href="tree_8hpp_source.html#l01266">fcarouge::tree&lt; Type, AllocatorType &gt;::emplace_root()</a>, <a class="el" href="tree_8hpp_source.html#l00750">fcarouge::tree&lt; Type, AllocatorType &gt;::empty()</a>, <a class="el" href="tree_8hpp_source.html#l00556">fcarouge::tree&lt; Type, AllocatorType &gt;::operator=()</a>, <a class="el" href="tree_8hpp_source.html#l01138">fcarouge::tree&lt; Type, AllocatorType &gt;::prune()</a>, and <a class="el" href="tree_8hpp_source.html#l00762">fcarouge::tree&lt; Type, AllocatorType &gt;::size()</a>.</p>

</div>
</div>
<a id="a31c6ea7623721e3563def6f479d3c31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c6ea7623721e3563def6f479d3c31c">&#9670;&nbsp;</a></span>root</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class AllocatorType  = std::allocator&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfcarouge_1_1tree_1_1internal__node__type.html">internal_node_type</a>* <a class="el" href="classfcarouge_1_1tree.html">fcarouge::tree</a>&lt; Type, AllocatorType &gt;::root = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The root node of the container. </p>

<p class="definition">Definition at line <a class="el" href="tree_8hpp_source.html#l01331">1331</a> of file <a class="el" href="tree_8hpp_source.html">tree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="tree_8hpp_source.html#l00662">fcarouge::tree&lt; Type, AllocatorType &gt;::begin()</a>, <a class="el" href="tree_8hpp_source.html#l00688">fcarouge::tree&lt; Type, AllocatorType &gt;::cbegin()</a>, <a class="el" href="tree_8hpp_source.html#l00797">fcarouge::tree&lt; Type, AllocatorType &gt;::clear()</a>, <a class="el" href="tree_8hpp_source.html#l01106">fcarouge::tree&lt; Type, AllocatorType &gt;::cleave()</a>, <a class="el" href="tree_8hpp_source.html#l00836">fcarouge::tree&lt; Type, AllocatorType &gt;::emplace()</a>, <a class="el" href="tree_8hpp_source.html#l01199">fcarouge::tree&lt; Type, AllocatorType &gt;::emplace_last_child()</a>, <a class="el" href="tree_8hpp_source.html#l01266">fcarouge::tree&lt; Type, AllocatorType &gt;::emplace_root()</a>, <a class="el" href="tree_8hpp_source.html#l00628">fcarouge::tree&lt; Type, AllocatorType &gt;::front()</a>, <a class="el" href="tree_8hpp_source.html#l00556">fcarouge::tree&lt; Type, AllocatorType &gt;::operator=()</a>, <a class="el" href="tree_8hpp_source.html#l00462">fcarouge::tree&lt; Type, AllocatorType &gt;::tree()</a>, and <a class="el" href="tree_8hpp_source.html#l00518">fcarouge::tree&lt; Type, AllocatorType &gt;::~tree()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/fcarouge/<a class="el" href="tree_8hpp_source.html">tree.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefcarouge.html">fcarouge</a></li><li class="navelem"><a class="el" href="classfcarouge_1_1tree.html">tree</a></li>
    <li class="footer">Generated on Fri Jan 29 2021 02:47:10 for Tree by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
